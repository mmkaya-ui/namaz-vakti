<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#059669">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Namaz ve Tesbih</title>
    
    <!-- PWA Manifest (Embedded) -->
    <link rel="manifest" href="data:application/manifest+json;base64,eyJuYW1lIjoiTmFtYXogdmUgVGVzYmloIiwic2hvcnRfbmFtZSI6Ik5hbWF6Iiwic3RhcnRfdXJsIjoiLiIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiNmZmZmZmYiLCJ0aGVtZV9jb2xvciI6IiMwNTk2NjkiLCJpY29ucyI6W3sic3JjIjoiaHR0cHM6Ly9jZG4taWNvbnMtcG5nLmZsYXRpY29uLmNvbS81MTIvNTEyMC81MTIwOTAxLnBuZyIsInNpemVzIjoiNTEyeDUxMiIsInR5cGUiOiJpbWFnZS9wbmcifV19">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        slate: { 850: '#1e293b' }
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
    
    <!-- React Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes fade-in { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fade-in 0.4s ease-out forwards; }
        /* Disable double-tap zoom on buttons for app-like feel */
        button { touch-action: manipulation; }
        body { 
            -webkit-tap-highlight-color: transparent; 
            min-height: 100vh;
        }
        /* Number input spinner hide */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        
        /* Zikir Circle Ripple Effect */
        .ripple-effect {
            position: relative;
            overflow: hidden;
        }
        .ripple-effect::after {
            content: "";
            display: block;
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            background-image: radial-gradient(circle, #10b981 10%, transparent 10.01%);
            background-repeat: no-repeat;
            background-position: 50%;
            transform: scale(10, 10);
            opacity: 0;
            transition: transform .5s, opacity 1s;
        }
        .ripple-effect:active::after {
            transform: scale(0, 0);
            opacity: .3;
            transition: 0s;
        }
    </style>
</head>
<body class="bg-slate-50 dark:bg-slate-900 text-slate-800 dark:text-slate-100 font-sans selection:bg-emerald-200 dark:selection:bg-emerald-800 transition-colors duration-300">
    <div id="root"></div>

    <script type="text/babel">
        // --- GLOBAL ERROR HANDLER ---
        window.addEventListener('unhandledrejection', (e) => {
            if (e.reason && (e.reason.toString().includes('AES') || e.reason.toString().includes('Geolocation'))) {
                e.preventDefault();
                console.warn("Suppressed external/environment error:", e.reason);
            }
        });

        const { useState, useEffect, useCallback, useMemo, memo } = React;

        // --- CONSTANTS ---
        const SURAH_NAMES_TR = [
            "Fatiha", "Bakara", "Ali İmran", "Nisa", "Maide", "En'am", "Araf", "Enfal", "Tevbe", "Yunus", "Hud", "Yusuf", "Ra'd", "İbrahim", "Hicr", "Nahl", "İsra", "Kehf", "Meryem", "Taha", "Enbiya", "Hac", "Mü'minun", "Nur", "Furkan", "Şuara", "Neml", "Kasas", "Ankebut", "Rum", "Lokman", "Secde", "Ahzab", "Sebe", "Fatır", "Yasin", "Saffat", "Sad", "Zümer", "Mü'min", "Fussilet", "Şura", "Zuhruf", "Duhan", "Casiye", "Ahkaf", "Muhammed", "Fetih", "Hucurat", "Kaf", "Zariyat", "Tur", "Necm", "Kamer", "Rahman", "Vakıa", "Hadid", "Mücadele", "Haşr", "Mümtehine", "Saf", "Cuma", "Münafikun", "Tegabun", "Talak", "Tahrim", "Mülk", "Kalem", "Hakka", "Mearic", "Nuh", "Cin", "Müzzemmil", "Müddessir", "Kıyamet", "İnsan", "Mürselat", "Nebe", "Naziat", "Abese", "Tekvir", "İnfitar", "Mutaffifin", "İnşikak", "Buruc", "Tarık", "A'la", "Gaşiye", "Fecr", "Beled", "Şems", "Leyl", "Duha", "İnşirah", "Tin", "Alak", "Kadir", "Beyyine", "Zilzal", "Adiyat", "Karia", "Tekasür", "Asr", "Hümeze", "Fil", "Kureyn", "Maun", "Kevser", "Kafirun", "Nasr", "Tebbet", "İhlas", "Felak", "Nas"
        ];
        const getSurahNameTR = (num) => (num > 0 && num <= 114) ? SURAH_NAMES_TR[num - 1] : "Surah " + num;

        // --- UTILS ---
        const turkify = (text) => {
            if(!text) return "";
            return text
                .replace(/'/g, '')
                .replace(/aa/g, 'â').replace(/Aa/g, 'Â')
                .replace(/ii/g, 'î').replace(/ee/g, 'î')
                .replace(/uu/g, 'û').replace(/oo/g, 'û')
                .replace(/sh/g, 'ş').replace(/Sh/g, 'Ş')
                .replace(/ch/g, 'ç').replace(/Ch/g, 'Ç')
                .replace(/gh/g, 'ğ').replace(/Gh/g, 'Ğ')
                .replace(/kh/g, 'h').replace(/Kh/g, 'H')
                .replace(/dh/g, 'z').replace(/Dh/g, 'Z')
                .replace(/th/g, 's').replace(/Th/g, 'S')
                .replace(/q/g, 'k').replace(/Q/g, 'K')
                .replace(/w/g, 'v').replace(/W/g, 'V')
                .replace(/j/g, 'c').replace(/J/g, 'C')
                .replace(/\b(Wa|Va)\b/gi, 'Ve').replace(/^Wa/g, 'Ve').replace(/ wa/g, ' ve').replace(/ va/g, ' ve')
                .replace(/ai/g, 'ey').replace(/ay/g, 'ey')
                .replace(/ou/g, 'u')
                .replace(/([^y])y\b/g, '$1i');
        };

        const processText = (text, lang) => {
            if (lang === 'tr') return turkify(text);
            return text; // English/German use raw transliteration (Latin)
        };

        const getEdition = (lang) => {
            if (lang === 'de') return 'de.aburida';
            if (lang === 'en') return 'en.sahih';
            return 'tr.diyanet';
        };

        const safeStorage = {
            getItem: (key) => { try { return localStorage.getItem(key); } catch (e) { return null; } },
            setItem: (key, val) => { try { localStorage.setItem(key, val); } catch (e) { } },
            removeItem: (key) => { try { localStorage.removeItem(key); } catch (e) { } }
        };

        // --- DATA FOR STATIC ZIKRS ---
        const ZIKR_DB = {
            fatiha: {
                tr: { t: "Elhamdülillâhi rabbil'alemin...", m: "Hamd, Alemlerin Rabbi, Rahman, Rahim, din gününün sahibi Allah'a mahsustur..." },
                en: { t: "Alhamdulillahi rabbil alamin...", m: "All praise is due to Allah, Lord of the worlds, The Entirely Merciful, The Especially Merciful..." },
                de: { t: "Alhamdulillahi rabbil alamin...", m: "Alles Lob gebührt Allah, dem Herrn der Welten, dem Allerbarmer, dem Barmherzigen..." }
            },
            estag: {
                tr: { t: "Estağfirullah el azim...", m: "Azim olan Allah'tan bağışlanma dilerim." },
                en: { t: "Astaghfirullah al-azim...", m: "I seek forgiveness from Allah, the Magnificent." },
                de: { t: "Astaghfirullah al-azim...", m: "Ich bitte Allah, den Allmächtigen, um Vergebung." }
            },
            salavatM: {
                tr: { t: "Allahümme salli alâ seyyidinâ Muhammedin ve alâ âli seyyidinâ Muhammed", m: "Allah'ım! Efendimiz Muhammed'e ve Efendimiz Muhammed'in ailesine salat eyle." },
                en: { t: "Allahumma salli ala sayyidina Muhammadin wa ala ali sayyidina Muhammad", m: "O Allah, send prayers upon our Master Muhammad and upon the family of our Master Muhammad." },
                de: { t: "Allahumma salli ala sayyidina Muhammadin wa ala ali sayyidina Muhammad", m: "O Allah, segne unseren Meister Muhammad und die Familie unseres Meisters Muhammad." }
            },
            salavatA: {
                tr: { t: "Allâhümme salli alâ seyyidinâ Âdem", m: "Allah'ım! Efendimiz Adem'e salat eyle." },
                en: { t: "Allahumma salli ala sayyidina Adam", m: "O Allah, send prayers upon our Master Adam." },
                de: { t: "Allahumma salli ala sayyidina Adam", m: "O Allah, segne unseren Meister Adam." }
            },
            salavatI: {
                tr: { t: "Allâhümme salli alâ seyyidinâ İsâ", m: "Allah'ım! Efendimiz İsa'ya salat eyle." },
                en: { t: "Allahumma salli ala sayyidina Isa", m: "O Allah, send prayers upon our Master Jesus." },
                de: { t: "Allahumma salli ala sayyidina Isa", m: "O Allah, segne unseren Meister Jesus." }
            },
            salavatB: {
                tr: { t: "Allâhumme salli alâ seyyidinâ Muhammedin ve alâ âli seyyidinâ Muhammed ve alâ ashâbi’l-Kehfi ve ashâbi’r-Rakîmi ve ashâbi Bedrin ve melaiketi Bedri, sallallâhu teâlâ aleyhi ve sellem.", m: "Allah'ım! Efendimiz Muhammed'e, ailesine, Ashab-ı Kehf'e, Rakim sahiplerine, Bedir ashabına ve Bedir meleklerine salat eyle." },
                en: { t: "Allahumma salli ala sayyidina Muhammadin wa ala ali sayyidina Muhammad wa ala ashab il-kahfi wa ashab ir-raqimi wa ashab i-badrin wa malaikati badrin...", m: "O Allah, send prayers upon our Master Muhammad, his family, the Companions of the Cave, the Companions of the Inscription, the Companions of Badr and the Angels of Badr." },
                de: { t: "Allahumma salli ala sayyidina Muhammadin wa ala ali sayyidina Muhammad...", m: "O Allah, segne unseren Meister Muhammad, seine Familie, die Gefährten der Höhle, die Leute der Inschrift, die Gefährten von Badr und die Engel von Badr." }
            },
            kuddus: {
                tr: { t: "Ya Kuddüs, Ya Kuddüs...", m: "Ey her türlü eksiklikten münezzeh olan." },
                en: { t: "Ya Quddus, Ya Quddus...", m: "O The Holy, O The Pure One." },
                de: { t: "Ya Quddus, Ya Quddus...", m: "O der Heilige, O der Reine." }
            }
        };

        // --- NOTIFICATION HELPER ---
        const requestNotificationPermission = async () => {
            if (!("Notification" in window)) {
                alert("Bu tarayıcı bildirimleri desteklemiyor.");
                return false;
            }
            try {
                const permission = await Notification.requestPermission();
                return permission === "granted";
            } catch (e) { return false; }
        };

        const sendNotification = (title, body) => {
            if ("Notification" in window && Notification.permission === "granted") {
                try {
                    new Notification(title, { body, icon: 'https://cdn-icons-png.flaticon.com/512/5110/5110594.png' });
                } catch(e) {}
            }
        };

        // --- ICONS ---
        const Icon = ({ path, size = 20, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{path}</svg>;
        const Icons = {
            MapPin: (p) => <Icon {...p} path={<><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/></>} />,
            Settings: (p) => <Icon {...p} path={<><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1-1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></>} />,
            Moon: (p) => <Icon {...p} path={<path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/>} />,
            Sun: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></>} />,
            BookOpen: (p) => <Icon {...p} path={<><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></>} />,
            CheckCircle: (p) => <Icon {...p} path={<><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><path d="m9 11 3 3L22 4"/></>} />,
            RefreshCw: (p) => <Icon {...p} path={<><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></>} />,
            Globe: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="10"/><path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"/><path d="M2 12h20"/></>} />,
            Navigation: (p) => <Icon {...p} path={<polygon points="3 11 22 2 13 21 11 13 3 11"/>} />,
            Clock: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></>} />,
            Menu: (p) => <Icon {...p} path={<><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></>} />,
            AlertTriangle: (p) => <Icon {...p} path={<><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></>} />,
            ChevronRight: (p) => <Icon {...p} path={<path d="m9 18 6-6-6-6"/>} />,
            Lock: (p) => <Icon {...p} path={<><rect width="18" height="11" x="3" y="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></>} />,
            Edit: (p) => <Icon {...p} path={<><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></>} />,
            Bell: (p) => <Icon {...p} path={<><path d="M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9"/><path d="M10.3 21a1.94 1.94 0 0 0 3.4 0"/></>} />,
            RotateCcw: (p) => <Icon {...p} path={<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 16" />} />,
            Type: (p) => <Icon {...p} path={<><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></>} />
        };
        const { MapPin, Settings, Moon, Sun, BookOpen, CheckCircle, RefreshCw, Globe, Navigation, Clock, Menu, AlertTriangle, ChevronRight, Lock, Edit, Bell, RotateCcw, Type } = Icons;

        // --- TRANSLATIONS ---
        const TRANSLATIONS = {
            tr: {
                appName: "Namaz ve Tesbih", location: "Konum", detectLocation: "Bul", searchCity: "Şehir...",
                prayerTimes: "Namaz Vakitleri", tasbeeh: "Tesbihat", quran: "Kur'an Oku", settings: "Ayarlar",
                times: "Vakitler",
                calcMethod: "Yöntem", language: "Dil", fajr: "İmsak", sunrise: "Güneş", dhuhr: "Öğle",
                asr: "İkindi", maghrib: "Akşam", isha: "Yatsı", midnight: "Gece Yarısı", teheccud: "Teheccüd",
                kerahatMorning: "İşrak", kerahatNoon: "İstiva", kerahatEvening: "İsfirar",
                remaining: "Kalan", loading: "Yükleniyor...", error: "Hata", morningZikr: "Sabah",
                ikindiZikr: "İkindi", nightZikr: "Yatsı", tapToCount: "Dokun",
                completed: "Tamamlandı", next: "İleri", nextZikr: "Sonraki", nextAyah: "Sıradaki",
                reset: "Sıfırla", manualLocation: "Konum", search: "Ara", randomAyahs: "Kur'an'dan Bir Sayfa",
                turkishTrans: "Okunuş", turkishMean: "Meal", amenarresulu: "Amenerrasulü",
                nextPrayer: "Vakit", now: "Şu an", bestTimeTeheccud: "Gece namazı vakti",
                kerahatHeader: "Kerahat", step: "Adım", target: "Hedef", loadContent: "Yükle",
                loadBtn: "Getir", readFirst10: "Kehf (İlk 10)", readLast10: "Kehf (Son 10)",
                read15Random: "1 Sayfa Oku", salavatAdam: "Adem (a.s)",
                salavatIsa: "İsa (a.s)", salavatMuhammed: "Salavat-ı Şerife",
                salavatBedr: "Bedir & Kehf Salavatı", tryAgain: "Tekrar Dene", connectionError: "Bağlantı Hatası",
                pageInfo: "Sayfa", asrMethod: "İkindi Yöntemi", standard: "Standart (Cumhur)", hanafi: "Hanefi (Geç İkindi)",
                timeAdjustments: "Vakit Düzeltmeleri (dk)", save: "Kaydet",
                enableNotifications: "Bildirim İzni Ver", notificationGranted: "Bildirim İzni Verildi", notifications: "Bildirimler",
                fontSize: "Yazı Boyutu", resetStep: "Sayacı Sıfırla"
            },
            en: {
                appName: "Prayer & Dhikr", location: "Location", detectLocation: "Find", searchCity: "City...",
                prayerTimes: "Times", tasbeeh: "Dhikr", quran: "Read Quran", settings: "Settings",
                times: "Times",
                calcMethod: "Method", language: "Lang", fajr: "Fajr", sunrise: "Sun", dhuhr: "Dhuhr",
                asr: "Asr", maghrib: "Maghrib", isha: "Isha", midnight: "Midnight", teheccud: "Tahajjud",
                kerahatMorning: "Ishraq", kerahatNoon: "Istiwa", kerahatEvening: "Isfirar",
                remaining: "Left", loading: "Loading...", error: "Error", morningZikr: "Morning",
                ikindiZikr: "Asr", nightZikr: "Night", tapToCount: "Tap",
                completed: "Done", next: "Next", nextZikr: "Next", nextAyah: "Next",
                reset: "Reset", manualLocation: "Loc", search: "Go", randomAyahs: "A Page in Quran",
                turkishTrans: "Transliteration", turkishMean: "Meaning", amenarresulu: "Amenarrasul",
                nextPrayer: "Next", now: "Now", bestTimeTeheccud: "Night prayer",
                kerahatHeader: "Kerahat", step: "Step", target: "Goal", loadContent: "Load",
                loadBtn: "Load", readFirst10: "Kahf (1-10)", readLast10: "Kahf (Last 10)",
                read15Random: "Read 1 Page", salavatAdam: "Adam (as)",
                salavatIsa: "Jesus (as)", salavatMuhammed: "Salawat",
                salavatBedr: "Badr & Kahf", tryAgain: "Try Again", connectionError: "Connection Error",
                pageInfo: "Page", asrMethod: "Asr Method", standard: "Standard", hanafi: "Hanafi",
                timeAdjustments: "Time Adjustments (min)", save: "Save",
                enableNotifications: "Enable Notifications", notificationGranted: "Notifications Enabled", notifications: "Notifications",
                fontSize: "Text Size", resetStep: "Reset Counter"
            },
            de: {
                appName: "Gebet & Tasbih", location: "Ort", detectLocation: "Finden", searchCity: "Stadt...",
                prayerTimes: "Zeiten", tasbeeh: "Tasbih", quran: "Koran", settings: "Optionen",
                times: "Zeiten",
                calcMethod: "Methode", language: "Sprache", fajr: "Fadschr", sunrise: "Sonne", dhuhr: "Dhuhur",
                asr: "Assr", maghrib: "Maghrib", isha: "Ischa", midnight: "Mitternacht", teheccud: "Tahajjud",
                kerahatMorning: "Ischraq", kerahatNoon: "Istiwa", kerahatEvening: "Isfirar",
                remaining: "Rest", loading: "Laden...", error: "Fehler", morningZikr: "Morgen",
                ikindiZikr: "Assr", nightZikr: "Nacht", tapToCount: "Tippen",
                completed: "Fertig", next: "Weiter", nextZikr: "Weiter", nextAyah: "Weiter",
                reset: "Reset", manualLocation: "Ort", search: "Suche", randomAyahs: "Eine Seite aus Koran",
                turkishTrans: "Aussprache", turkishMean: "Bedeutung", amenarresulu: "Amenarrasul",
                nextPrayer: "Nächstes", now: "Jetzt", bestTimeTeheccud: "Nachtgebet",
                kerahatHeader: "Kerahat", step: "Schritt", target: "Ziel", loadContent: "Laden",
                loadBtn: "Laden", readFirst10: "Kahf (1-10)", readLast10: "Kahf (Letzte)",
                read15Random: "1 Seite Lesen", salavatAdam: "Adam (as)",
                salavatIsa: "Jesus (as)", salavatMuhammed: "Salavat",
                salavatBedr: "Badr & Kahf", tryAgain: "Wiederholen", connectionError: "Verbindungsfehler",
                pageInfo: "Seite", asrMethod: "Assr Methode", standard: "Standard", hanafi: "Hanafi",
                timeAdjustments: "Zeitanpassungen (Min)", save: "Speichern",
                enableNotifications: "Benachrichtigungen aktivieren", notificationGranted: "Benachrichtigungen aktiviert", notifications: "Benachrichtigungen",
                fontSize: "Textgröße", resetStep: "Reset"
            }
        };

        const CALCULATION_METHODS = [
            { id: 13, name: 'Diyanet', short: 'Diyanet' },
            { id: 3, name: 'Muslim World League', short: 'MWL' },
            { id: 2, name: 'ISNA', short: 'ISNA' },
            { id: 5, name: 'Egypt', short: 'Egypt' },
        ];

        // --- 3. LOGIC ---
        const useTime = () => {
            const [time, setTime] = useState(new Date());
            useEffect(() => {
                const timer = setInterval(() => setTime(new Date()), 1000);
                return () => clearInterval(timer);
            }, []);
            return time;
        };

        const useGeolocation = (t) => {
            const [coords, setCoords] = useState(null);
            const [locationName, setLocationName] = useState('');
            const [loading, setLoading] = useState(false);

            const setDefault = useCallback(() => {
                if (!coords) {
                    setCoords({ lat: 41.0082, lng: 28.9784 });
                    setLocationName("İstanbul");
                }
            }, [coords]);

            useEffect(() => {
                const storedCoords = safeStorage.getItem('coords');
                const storedName = safeStorage.getItem('locName');
                if (storedCoords) setCoords(JSON.parse(storedCoords));
                if (storedName) setLocationName(storedName);
                if (!storedCoords) getUserLocation();
            }, []);

            const getUserLocation = useCallback(() => {
                if (!navigator.geolocation) {
                    setDefault();
                    return;
                }
                setLoading(true);
                const geoTimeout = setTimeout(() => { setLoading(false); setDefault(); }, 10000);

                try {
                    navigator.geolocation.getCurrentPosition(
                        async (pos) => {
                            clearTimeout(geoTimeout);
                            try {
                                const newCoords = { lat: pos.coords.latitude, lng: pos.coords.longitude };
                                setCoords(newCoords);
                                safeStorage.setItem('coords', JSON.stringify(newCoords));
                                
                                try {
                                    const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${newCoords.lat}&lon=${newCoords.lng}`);
                                    if (!res.ok) throw new Error("Network response not ok");
                                    const data = await res.json();
                                    const name = data.address.city || data.address.town || data.address.suburb || "Loc";
                                    setLocationName(name);
                                    safeStorage.setItem('locName', name);
                                } catch(e) { 
                                    setLocationName(t('location')); 
                                }
                            } catch (err) { 
                                setDefault();
                            } finally { 
                                setLoading(false); 
                            }
                        },
                        (err) => { 
                            console.warn("Geo error:", err);
                            clearTimeout(geoTimeout); 
                            setLoading(false); 
                            setDefault(); 
                        },
                        { timeout: 5000, enableHighAccuracy: false }
                    );
                } catch (e) {
                    console.warn("Geo sync error:", e);
                    clearTimeout(geoTimeout);
                    setLoading(false);
                    setDefault();
                }
            }, [coords, t, setDefault]);

            const searchLocation = useCallback(async (query) => {
                if (!query) return;
                setLoading(true);
                try {
                    const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${query}`);
                    if (!res.ok) throw new Error("Network Error");
                    const data = await res.json();
                    if (data && data.length > 0) {
                        const place = data[0];
                        const newCoords = { lat: parseFloat(place.lat), lng: parseFloat(place.lon) };
                        setCoords(newCoords);
                        const name = place.display_name.split(',')[0];
                        setLocationName(name);
                        safeStorage.setItem('coords', JSON.stringify(newCoords));
                        safeStorage.setItem('locName', name);
                    } else { alert("Not found"); }
                } catch(e) { alert(t('error')); }
                setLoading(false);
            }, [t]);

            return useMemo(() => ({ coords, locationName, loading, getUserLocation, searchLocation }), [coords, locationName, loading, getUserLocation, searchLocation]);
        };

        const usePrayerTimes = (coords, methodId, asrMethod) => {
            const [data, setData] = useState(null);
            const [loading, setLoading] = useState(false);

            useEffect(() => {
                if (!coords) return;
                const controller = new AbortController();
                const fetchTimes = async () => {
                    setLoading(true);
                    try {
                        const date = new Date();
                        const strDate = `${date.getDate()}-${date.getMonth() + 1}-${date.getFullYear()}`;
                        const schoolParam = asrMethod === 1 ? '&school=1' : '&school=0';
                        const res = await fetch(`https://api.aladhan.com/v1/timings/${strDate}?latitude=${coords.lat}&longitude=${coords.lng}&method=${methodId}${schoolParam}`, { signal: controller.signal });
                        const json = await res.json();
                        if (json.code === 200) setData(json.data);
                    } catch (e) { }
                    setLoading(false);
                };
                fetchTimes();
                return () => controller.abort();
            }, [coords, methodId, asrMethod]);

            return { data, loading };
        };

        const fmt = (date) => date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        // --- 4. COMPONENTS ---

        const LoadingView = () => (
            <div className="flex justify-center items-center p-8"><div className="animate-spin rounded-full h-8 w-8 border-b-2 border-emerald-600 dark:border-emerald-400"></div></div>
        );

        const Header = memo(({ currentTime, appName, toggleTheme, isDarkMode }) => (
            <header className="fixed top-0 left-0 right-0 mx-auto max-w-md bg-white dark:bg-slate-850 z-50 border-b border-slate-50 dark:border-slate-800 transition-colors duration-300">
                <div className="px-4 pt-4 pb-2 flex justify-between items-center">
                    <div className="flex items-center space-x-2">
                        <div className="w-8 h-8 bg-emerald-600 rounded-lg flex items-center justify-center text-white"><Moon size={18} /></div>
                        <span className="font-bold text-base tracking-tight text-slate-800 dark:text-slate-100">{appName}</span>
                    </div>
                    <div className="flex items-center space-x-2">
                        <div className="text-sm font-mono font-bold text-emerald-600 dark:text-emerald-400 bg-slate-100 dark:bg-slate-800 px-2 py-1 rounded">{fmt(currentTime)}</div>
                        <button onClick={toggleTheme} className="text-slate-500 dark:text-slate-400 p-1 hover:bg-slate-100 dark:hover:bg-slate-800 rounded-full transition-colors">
                            {isDarkMode ? <Sun size={18} /> : <Moon size={18} />}
                        </button>
                    </div>
                </div>
            </header>
        ));

        const ProgressBar = ({ current, total }) => (
            <div className="w-full bg-gray-200 dark:bg-slate-700 rounded-full h-2 mt-1"><div className="bg-emerald-600 h-2 rounded-full transition-all duration-300 ease-out" style={{ width: `${Math.min(100, (current / total) * 100)}%` }}></div></div>
        );

        const ResetBtn = ({ onClick, t }) => (
             <button onClick={(e) => { e.stopPropagation(); onClick(); }} className="px-2 py-1 rounded-md bg-orange-50 dark:bg-orange-900/20 text-orange-600 dark:text-orange-400 hover:bg-orange-100 dark:hover:bg-orange-900/40 transition flex items-center space-x-1 border border-orange-100 dark:border-orange-900/30" title={t('resetStep')}>
                 <RotateCcw size={12} />
                 <span className="text-[10px] font-bold uppercase tracking-wider">{t('reset')}</span>
             </button>
        );

        // -- FETCHABLE CARD COMPONENT (Replaces KehfCard, AmenarresuluCard static logic) --
        const FetchableZikrCard = memo(({ current, count, next, tap, cooldown, t, resetLocal, fontSize, lang }) => {
            const [data, setData] = useState(null);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(false);

            useEffect(() => {
                let isMounted = true;
                const fetchData = async () => {
                    setLoading(true);
                    setError(false);
                    try {
                        const edition = getEdition(lang);
                        let url = '';
                        // Determine API URL based on type
                        if (current.type === 'kehf_first_10') {
                            url = `https://api.alquran.cloud/v1/surah/18/editions/quran-uthmani,${edition},en.transliteration?offset=0&limit=10`;
                        } else if (current.type === 'kehf_last_10') {
                            url = `https://api.alquran.cloud/v1/surah/18/editions/quran-uthmani,${edition},en.transliteration?offset=100&limit=10`;
                        } else if (current.type === 'amenarresulu') {
                            url = `https://api.alquran.cloud/v1/surah/2/editions/quran-uthmani,${edition},en.transliteration?offset=284&limit=2`;
                        }

                        if (url) {
                            const res = await fetch(url);
                            if(!res.ok) throw new Error("API Error");
                            const json = await res.json();
                            if (json.code === 200 && isMounted) {
                                // Structure: json.data is array of 3 editions [Arabic, Translation, Transliteration]
                                const arabic = json.data[0].ayahs;
                                const translation = json.data[1].ayahs;
                                const transliteration = json.data[2].ayahs;
                                
                                const processed = arabic.map((a, i) => ({
                                    arabic: a.text,
                                    mean: translation[i].text,
                                    trans: processText(transliteration[i].text, lang),
                                    number: a.numberInSurah
                                }));
                                setData(processed);
                            } else { throw new Error("API Data Error"); }
                        }
                    } catch (e) {
                        console.error(e);
                        if (isMounted) setError(true);
                    } finally {
                        if (isMounted) setLoading(false);
                    }
                };
                
                fetchData();
                return () => { isMounted = false; };
            }, [current.type, lang]);

            if (loading) return <div className="h-full flex items-center justify-center"><LoadingView /></div>;
            if (error || !data) return (
                <div className="h-full flex flex-col items-center justify-center p-4 border border-red-200 rounded-2xl">
                    <p className="text-red-500 mb-2 text-xs">{t('connectionError')}</p>
                    <button onClick={next} className="bg-slate-100 dark:bg-slate-700 px-3 py-1.5 rounded text-xs text-slate-600 dark:text-slate-300">{t('next')}</button>
                </div>
            );

            // Determine which ayah to show
            // For Kehf 1-10/Last 10: count goes 0..9.
            // For Amenarresulu: count goes 0..target. 
            // Amenarresulu logic: usually read full block, or 1 by 1. 
            // The existing app logic seems to treat Amenarresulu as 1 block repeated or steps.
            // Let's assume for reading cards like Kehf, we show 1 ayah per step.
            
            // Safe index access
            const idx = Math.min(count, data.length - 1);
            const item = data[idx];
            const isLast = count >= current.target - 1;

            return (
                <div className="bg-white dark:bg-slate-850 border border-slate-200 dark:border-slate-800 rounded-2xl p-4 shadow-sm relative overflow-hidden flex flex-col transition-colors duration-300 h-full">
                    <div className="flex justify-between items-center mb-2 text-xs">
                        <div className="flex items-center space-x-1 text-emerald-600 dark:text-emerald-400 font-bold"><BookOpen size={16}/><span>{current.title}</span></div>
                        <div className="flex items-center space-x-2">
                            <span className="bg-slate-100 dark:bg-slate-800 px-1.5 py-0.5 rounded text-slate-500 dark:text-slate-400 font-mono">{Math.min(count + 1, current.target)}/{current.target}</span>
                            <ResetBtn onClick={resetLocal} t={t} />
                        </div>
                    </div>
                    <div className="mb-2 overflow-y-auto flex-1 space-y-2">
                        {current.type === 'amenarresulu' ? (
                            // Show all for Amenarresulu usually, but if step by step requested:
                            // Let's show currently indexed part but if it's the last step maybe show all?
                            // Actually user wants standard zikrmatik feel.
                            // If target is 11 (amenarresulu in zikrList), it means repeat 11 times or read 11 parts? 
                            // Usually Amenarresulu is read once. Zikr list target=11 implies 11 repetitions? 
                            // In v2 code it was single card. Let's assume it's read ONCE but maybe split in 2 ayahs?
                            // No, typically Amenarresulu is treated as a single reading item in lists.
                            // However, the previous code had a counter. 
                            // If it is a counter (e.g. 11 times), we show the full text always.
                            // If it is reading (Kehf), we show ayah by ayah.
                            // Let's check zikrList: amena target is 11. 
                            // So it's a counter. We show FULL TEXT.
                            <div className="space-y-3">
                                {data.map((d, i) => (
                                    <div key={i}>
                                        <p className="text-right font-serif text-lg text-emerald-800 dark:text-emerald-400 mb-1" dir="rtl">{d.arabic}</p>
                                        <p className="text-slate-800 dark:text-slate-200 font-medium text-xs mb-1">{d.trans}</p>
                                        <p className="text-slate-500 dark:text-slate-400 text-[10px] italic">{d.mean}</p>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            // Kehf -> Ayah by Ayah
                            <>
                                <p className="text-right font-serif text-xl text-emerald-800 dark:text-emerald-400 mb-2" dir="rtl">{item.arabic}</p>
                                <p className="text-slate-800 dark:text-slate-200 font-semibold mb-1 leading-relaxed" style={{ fontSize: `${fontSize * 0.85}rem` }}>{item.trans}</p>
                                <p className="text-slate-600 dark:text-slate-400 italic" style={{ fontSize: `${fontSize * 0.75}rem` }}>{item.mean}</p>
                            </>
                        )}
                    </div>
                    <button onClick={isLast ? next : tap} disabled={cooldown} className={`w-full py-2.5 rounded-lg font-bold flex justify-center items-center space-x-1 transition text-sm shrink-0 ${cooldown ? 'bg-slate-200 dark:bg-slate-700 text-slate-400 dark:text-slate-500' : 'bg-emerald-600 text-white active:scale-95'}`}>
                        {cooldown ? <Lock size={16}/> : <span>{isLast ? t('completed') : (current.type === 'amenarresulu' ? t('tapToCount') : t('nextAyah'))}</span>}
                    </button>
                </div>
            );
        });

        const MultiAyahReadingCard = memo(({ current, next, cooldown, t, fontSize, lang }) => {
            const [ayahs, setAyahs] = useState(null);
            const [loading, setLoading] = useState(true);
            const [localIndex, setLocalIndex] = useState(0);
            const [error, setError] = useState(false);

            useEffect(() => {
                let isMounted = true;
                const fetchSequential = async () => {
                    try {
                        const randomPage = Math.floor(Math.random() * 604) + 1; 
                        const edition = getEdition(lang);

                        const [p1, p2, p3] = await Promise.all([
                            fetch(`https://api.alquran.cloud/v1/page/${randomPage}/quran-uthmani`),
                            fetch(`https://api.alquran.cloud/v1/page/${randomPage}/${edition}`),
                            fetch(`https://api.alquran.cloud/v1/page/${randomPage}/en.transliteration`)
                        ]);

                        if (!isMounted) return;

                        if (!p1.ok || !p2.ok || !p3.ok) throw new Error('Network response was not ok');

                        const d1 = await p1.json();
                        const d2 = await p2.json();
                        const d3 = await p3.json();

                        if (d1.code === 200 && d2.code === 200 && d3.code === 200) {
                            const combined = d1.data.ayahs.map((ayah, i) => {
                                const rawTrans = d3.data.ayahs[i] ? d3.data.ayahs[i].text : '';
                                return {
                                    arabic: ayah.text,
                                    text: d2.data.ayahs[i] ? d2.data.ayahs[i].text : '',
                                    trans: processText(rawTrans, lang),
                                    info: `${getSurahNameTR(ayah.surah.number)} : ${ayah.numberInSurah}`
                                };
                            }); 

                            if (combined.length > 0) {
                                setAyahs(combined);
                                setLoading(false);
                            } else { setError(true); }
                        } else { setError(true); }
                    } catch (e) {
                        console.error("Fetch Error:", e);
                        if (isMounted) { setError(true); setLoading(false); }
                    }
                };                
                fetchSequential();
                return () => { isMounted = false; };
            }, [lang]);

            if (error) return ( 
                 <div className="bg-white dark:bg-slate-850 border border-red-200 dark:border-red-900 rounded-2xl p-4 flex flex-col items-center justify-center text-center h-full transition-colors duration-300">
                    <p className="text-red-500 mb-2 text-xs">{t('connectionError')}</p>
                    <button onClick={next} className="bg-slate-100 dark:bg-slate-700 px-3 py-1.5 rounded text-xs text-slate-600 dark:text-slate-300">{t('next')}</button>
                 </div>
            );

            if (loading || !ayahs) return <LoadingView />;
            const currentAyah = ayahs[localIndex];
            if (!currentAyah) return <div onClick={next} className="p-4 text-center text-xs">Loading error. Tap to skip.</div>;

            const isLast = localIndex >= ayahs.length - 1;
            const handleNext = () => { if (isLast) next(); else setLocalIndex(i => i + 1); };

            return (
                <div className="bg-white dark:bg-slate-850 border border-slate-200 dark:border-slate-800 rounded-2xl p-4 shadow-sm relative overflow-hidden flex flex-col h-full transition-colors duration-300">
                    <div className="flex justify-between items-center mb-2 text-xs shrink-0">
                        <div className="flex items-center space-x-1 text-emerald-600 dark:text-emerald-400 font-bold">
                            <BookOpen size={16}/><span>{current.title}</span>
                        </div>
                        <span className="bg-slate-100 dark:bg-slate-800 px-1.5 py-0.5 rounded text-slate-500 dark:text-slate-400 font-mono">{localIndex + 1}/{ayahs.length}</span>
                    </div>
                    <div className="flex-1 overflow-y-auto mb-2">
                        <div className="mb-1 text-[10px] text-emerald-600 dark:text-emerald-500 font-bold uppercase tracking-wider">{currentAyah.info}</div>
                        <p className="text-right font-serif text-lg text-emerald-800 dark:text-emerald-400 mb-2 leading-relaxed" dir="rtl">{currentAyah.arabic}</p>
                        <p className="text-slate-800 dark:text-slate-200 font-medium mb-1" style={{ fontSize: `${fontSize * 0.75}rem` }}>{currentAyah.trans}</p>
                        <p className="text-slate-500 dark:text-slate-400 italic" style={{ fontSize: `${fontSize * 0.65}rem` }}>{currentAyah.text}</p>
                    </div>
                    <button onClick={handleNext} className="w-full py-2.5 rounded-lg font-bold bg-emerald-600 text-white active:scale-95 transition text-sm">
                        {isLast ? t('completed') : t('nextAyah')}
                    </button>
                </div>
            );
        });

        const CounterCard = memo(({ current, count, next, tap, cooldown, t, index, totalLength, resetLocal, fontSize }) => {
            const done = count >= current.target;
            return (
                <div className={`border-2 rounded-2xl p-3 flex flex-col items-center text-center shadow-sm transition-colors duration-300 select-none h-full relative ${done ? 'bg-emerald-50 dark:bg-emerald-900/30 border-emerald-500' : 'bg-white dark:bg-slate-850 border-emerald-100 dark:border-slate-700'}`}>
                    <div className="w-full flex justify-between text-[10px] text-slate-400 dark:text-slate-500 font-medium mb-1 relative z-10">
                        <span>{t('step')} {index + 1}/{totalLength}</span>
                        <div className="flex items-center gap-2">
                             <span className="text-xs font-bold text-slate-600 dark:text-slate-300">{t('target')}: {current.target}</span>
                             <ResetBtn onClick={resetLocal} t={t} />
                        </div>
                    </div>
                    <ProgressBar current={count} total={current.target}/>
                    
                    <div className="my-2 flex-1 flex flex-col justify-center w-full cursor-pointer" onClick={!done ? tap : undefined}>
                        <h2 className="text-lg font-bold text-slate-800 dark:text-slate-100 mb-1">{current.title}</h2>
                        {current.arabic && <p className="text-2xl font-serif text-emerald-600 dark:text-emerald-400 dir-rtl mb-2">{current.arabic}</p>}
                        <p className="text-slate-500 dark:text-slate-400 leading-relaxed mx-auto max-w-[280px]" style={{ fontSize: `${fontSize * 0.75}rem` }}>{current.text}</p>
                        
                        {!done && (
                             <div className="mt-4 mx-auto w-48 h-48 rounded-full border-8 border-slate-100 dark:border-slate-700 flex items-center justify-center bg-emerald-50 dark:bg-slate-800 shadow-inner ripple-effect transition-transform active:scale-95">
                                <span className="text-6xl font-mono font-bold text-emerald-600 dark:text-emerald-400 select-none">{count}</span>
                            </div>
                        )}
                         {!done && <span className="mt-2 text-[10px] text-slate-400 dark:text-slate-500 bg-slate-100 dark:bg-slate-800 px-3 py-1 rounded-full font-medium mx-auto">{t('tapToCount')}</span>}
                    </div>

                    {done && (
                        <button onClick={next} disabled={cooldown} className={`w-full py-2.5 rounded-lg font-bold text-white flex justify-center items-center space-x-1 transition text-sm ${cooldown ? 'bg-slate-400 dark:bg-slate-600' : 'bg-emerald-600 animate-pulse-slow'}`}>
                            <span>{t('nextZikr')}</span><ChevronRight size={16}/>
                        </button>
                    )}
                </div>
            );
        });

        const ReadingCard = memo(({ current, next, cooldown, t, fontSize }) => (
            <div className="bg-white dark:bg-slate-850 border border-slate-200 dark:border-slate-800 rounded-2xl p-4 flex flex-col items-center text-center shadow-sm transition-colors duration-300 h-full justify-center">
                <BookOpen size={32} className="text-emerald-500 mb-2"/>
                <h3 className="text-lg font-bold text-slate-800 dark:text-slate-100 mb-1">{current.title}</h3>
                <p className="text-slate-600 dark:text-slate-400 mb-3" style={{ fontSize: `${fontSize * 0.75}rem` }}>{current.text}</p>
                <button onClick={next} disabled={cooldown} className={`w-full py-2.5 rounded-lg font-bold transition text-sm ${cooldown ? 'bg-slate-300 dark:bg-slate-600' : 'bg-emerald-600 text-white'}`}>
                    {cooldown ? <Lock size={16} className="mx-auto"/> : t('completed')}
                </button>
            </div>
        ));

        // --- MAIN VIEWS ---

        const PrayerTimesView = memo(({ prayerData, currentTime, locationName, t, loading, offsets }) => {
            if (loading || !prayerData) return <LoadingView />;
            const timings = prayerData.timings;
            
            const applyOffset = (date, minutes) => {
                if (!date) return null;
                const newDate = new Date(date);
                const offsetMin = parseInt(minutes);
                if (!isNaN(offsetMin)) {
                    newDate.setMinutes(newDate.getMinutes() + offsetMin);
                }
                return newDate;
            };

            const parseAndAdjust = (timeStr, offset) => {
                if (!timeStr) return null;
                const [h, m] = timeStr.split(' ')[0].split(':').map(Number);
                const d = new Date(); d.setHours(h, m, 0, 0);
                return applyOffset(d, offset);
            };

            const times = { 
                fajr: parseAndAdjust(timings.Fajr, offsets.fajr), 
                sunrise: parseAndAdjust(timings.Sunrise, offsets.sunrise), 
                dhuhr: parseAndAdjust(timings.Dhuhr, offsets.dhuhr), 
                asr: parseAndAdjust(timings.Asr, offsets.asr), 
                maghrib: parseAndAdjust(timings.Maghrib, offsets.maghrib), 
                isha: parseAndAdjust(timings.Isha, offsets.isha) 
            };
            
            const ishraqEnd = new Date(times.sunrise.getTime() + 45 * 60000);
            const istiwaStart = new Date(times.dhuhr.getTime() - 45 * 60000);
            const isfirarStart = new Date(times.maghrib.getTime() - 45 * 60000);
            const fajrTomorrow = new Date(times.fajr);
            fajrTomorrow.setDate(fajrTomorrow.getDate() + 1);
            const teheccudStart = new Date(fajrTomorrow.getTime() - ((fajrTomorrow - times.maghrib) / 3));
            
            const now = currentTime.getTime();
            let nextP = t('fajr'), nextT = new Date(times.fajr); nextT.setDate(nextT.getDate() + 1);
            
            if (now < times.fajr.getTime()) { nextP = t('fajr'); nextT = times.fajr; }
            else if (now < times.sunrise.getTime()) { nextP = t('sunrise'); nextT = times.sunrise; }
            else if (now < times.dhuhr.getTime()) { nextP = t('dhuhr'); nextT = times.dhuhr; }
            else if (now < times.asr.getTime()) { nextP = t('asr'); nextT = times.asr; }
            else if (now < times.maghrib.getTime()) { nextP = t('maghrib'); nextT = times.maghrib; }
            else if (now < times.isha.getTime()) { nextP = t('isha'); nextT = times.isha; }

            const diff = nextT - now;
            const diffH = Math.floor(diff / 3600000);
            const diffM = Math.floor((diff % 3600000) / 60000);
            
            const fmt = (d) => d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});

            return (
                <div className="space-y-1.5 animate-fade-in pt-12 pb-14">
                    <div className="bg-gradient-to-br from-emerald-600 to-teal-800 rounded-2xl p-3 min-h-[100px] text-white shadow-lg relative overflow-hidden transition-colors duration-300">
                        <div className="absolute top-0 right-0 opacity-10 transform translate-x-4 -translate-y-4"><Moon size={100} /></div>
                        <div className="relative z-10 flex justify-between items-start mb-2">
                            <div><h2 className="text-emerald-100 text-xs font-medium uppercase tracking-wider">{t('nextPrayer')}</h2><h1 className="text-2xl font-bold mt-1">{nextP}</h1></div>
                            <div className="text-right"><p className="text-emerald-100 text-xs">{t('remaining')}</p><p className="text-2xl font-mono font-semibold mt-1">{diffH > 0 ? `${diffH}h ` : ''}{diffM}m</p></div>
                        </div>
                        <div className="flex items-center space-x-2 text-xs text-emerald-100 bg-emerald-900/30 w-fit px-2 py-1 rounded-full backdrop-blur-sm relative z-10"><MapPin size={12} /><span>{locationName}</span></div>
                    </div>
                    <div className="bg-white dark:bg-slate-850 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800 overflow-hidden transition-colors duration-300">
                        {[{ k: 'fajr', i: Moon }, { k: 'sunrise', i: Sun }, { k: 'dhuhr', i: Sun }, { k: 'asr', i: Sun }, { k: 'maghrib', i: Moon }, { k: 'isha', i: Moon }].map((o, idx) => (
                            <div key={idx} className="flex items-center justify-between px-3 py-0.5 border-b border-slate-50 dark:border-slate-800 last:border-0 hover:bg-slate-50 dark:hover:bg-slate-800/50">
                                <div className="flex items-center space-x-3 text-slate-700 dark:text-slate-300 font-medium"><span className="text-emerald-600 dark:text-emerald-400 bg-emerald-50 dark:bg-emerald-900/30 p-1.5 rounded-lg"><o.i size={18} /></span><span className="text-sm">{t(o.k)}</span></div>
                                <span className="font-mono font-bold text-base text-slate-800 dark:text-slate-200">{fmt(times[o.k])}</span>
                            </div>
                        ))}
                    </div>
                    <div className="space-y-2">
                        <div className="bg-indigo-50 dark:bg-indigo-900/20 border border-indigo-100 dark:border-indigo-800 rounded-xl p-1.5 flex justify-between items-center transition-colors duration-300">
                            <div className="flex items-center space-x-3"><div className="bg-indigo-100 dark:bg-indigo-800/40 text-indigo-600 dark:text-indigo-300 p-1.5 rounded-lg"><Moon size={16} /></div><div><p className="text-indigo-900 dark:text-indigo-200 font-bold text-sm">{t('teheccud')}</p><p className="text-[10px] text-indigo-600 dark:text-indigo-400 max-w-[150px] leading-tight">{t('bestTimeTeheccud')}</p></div></div>
                            <span className="font-mono font-bold text-indigo-800 dark:text-indigo-300 text-xs">{fmt(teheccudStart)} - {fmt(fajrTomorrow)}</span>
                        </div>
                        <div className="bg-amber-50 dark:bg-amber-900/20 border border-amber-100 dark:border-amber-800 rounded-xl overflow-hidden transition-colors duration-300">
                            <div className="p-1.5 bg-amber-100/50 dark:bg-amber-800/30 border-b border-amber-100 dark:border-amber-800 text-amber-800 dark:text-amber-200 font-semibold text-xs flex items-center"><span className="mr-2"><AlertTriangle size={14} /></span> {t('kerahatHeader')}</div>
                            <div className="divide-y divide-amber-100 dark:divide-amber-800">
                                <div className="p-1.5 flex justify-between text-xs text-amber-900 dark:text-amber-100"><span>{t('kerahatMorning')}</span><span className="font-mono font-medium">{fmt(times.sunrise)} - {fmt(ishraqEnd)}</span></div>
                                <div className="p-1.5 flex justify-between text-xs text-amber-900 dark:text-amber-100"><span>{t('kerahatNoon')}</span><span className="font-mono font-medium">{fmt(istiwaStart)} - {fmt(times.dhuhr)}</span></div>
                                <div className="p-1.5 flex justify-between text-xs text-amber-900 dark:text-amber-100"><span>{t('kerahatEvening')}</span><span className="font-mono font-medium">{fmt(isfirarStart)} - {fmt(times.maghrib)}</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        });

        const TasbeehView = memo(({ t, fontSize, lang }) => {
            const [mode, setMode] = useState('morning');
            const [index, setIndex] = useState(0);
            const [count, setCount] = useState(0);
            const [cooldown, setCooldown] = useState(false);
            const [isFinishedToday, setIsFinishedToday] = useState(false);

            useEffect(() => {
                const today = new Date().toISOString().split('T')[0];
                const savedStatus = safeStorage.getItem(`tasbeeh_status_${mode}`);                
                const savedProgress = safeStorage.getItem(`tasbeeh_progress_${mode}`);

                if (savedStatus) {
                    const { date, finished } = JSON.parse(savedStatus);
                    if (date === today && finished) { 
                         setIsFinishedToday(true); 
                         setIndex(0); setCount(0); 
                         return; 
                    } else {
                        setIsFinishedToday(false);
                    }
                } else {
                    setIsFinishedToday(false);
                }

                if (savedProgress) {
                    const { date, idx, cnt } = JSON.parse(savedProgress);
                    setIndex(idx || 0);
                    setCount(cnt || 0);
                } else {
                    setIndex(0);
                    setCount(0);
                }

            }, [mode]);

            const saveProgress = useCallback((idx, cnt) => { 
                 const today = new Date().toISOString().split('T')[0];
                 safeStorage.setItem(`tasbeeh_progress_${mode}`, JSON.stringify({ date: today, idx, cnt }));
            }, [mode]);

            const handleCompletion = useCallback(() => {
                const today = new Date().toISOString().split('T')[0];
                safeStorage.setItem(`tasbeeh_status_${mode}`, JSON.stringify({ date: today, finished: true }));
                safeStorage.removeItem(`tasbeeh_progress_${mode}`); 
                sendNotification("Tesbihat Tamamlandı", `${t(mode + 'Zikr')} başarıyla tamamlandı.`);
                setIsFinishedToday(true);
            }, [mode, t]);

            const reset = useCallback(() => {
                const today = new Date().toISOString().split('T')[0];
                safeStorage.removeItem(`tasbeeh_status_${mode}`);
                safeStorage.removeItem(`tasbeeh_progress_${mode}`);
                setIsFinishedToday(false);
                setIndex(0); setCount(0); setCooldown(false);
            }, [mode]);
            
            const resetLocal = useCallback(() => {
                setCount(0);
                saveProgress(index, 0);
            }, [index, saveProgress]);

            const zikrList = useMemo(() => {
                const db = ZIKR_DB; // Alias for cleaner code
                // Get correct lang texts, fallback to 'en' if missing
                const getZikr = (key) => (db[key][lang] || db[key]['en']);

                const common = {
                    fatiha: { target: 19, title: "Fatiha", text: getZikr('fatiha').t, arabic: "الْحَمْدُ لِلَّهِ رَبِّ الْعَالَمِينَ" },
                    estag: { target: 100, title: "Estağfirullah", text: getZikr('estag').t, arabic: "أَسْتَغْفِرُ اللّٰهَ" },
                    salavatM: { target: 10, title: t('salavatMuhammed'), text: getZikr('salavatM').t, arabic: "اللَّهُمَّ صَلِّ عَلَى سَيِّدِنَا مُحَمَّدٍ وَعَلَى آلِ سَيِّدِنَا مُحَمَّدٍ" },
                    salavatA: { target: 10, title: t('salavatAdam'), text: getZikr('salavatA').t, arabic: "اللَّهُمَّ صَلِّ عَلَى سَيِّدِنَا آدَمَ" },
                    salavatI: { target: 10, title: t('salavatIsa'), text: getZikr('salavatI').t, arabic: "اللَّهُمَّ صَلِّ عَلَى سَيِّدِنَا عِيسَى" },
                    kehf1: { target: 10, title: t('readFirst10'), type: 'kehf_first_10', isReading: true },
                    kehf2: { target: 10, title: t('readLast10'), type: 'kehf_last_10', isReading: true },
                    salavatB: { target: 10, title: t('salavatBedr'), text: getZikr('salavatB').t },
                    kuddus: { target: 40, title: "Ya Kuddüs", text: getZikr('kuddus').t, arabic: "يَا قُدُّوسُ" },
                    random: { target: 1, title: t('read15Random'), type: 'random15', isReading: true },
                    amena: { target: 11, title: t('amenarresulu'), type: 'amenarresulu' }
                };
                if(mode === 'morning') return [common.fatiha, common.estag, common.salavatA, common.salavatI, common.salavatM, common.kehf1, common.salavatB];
                if(mode === 'ikindi') return [{...common.fatiha, target: 21}, {...common.salavatM, target: 11}, common.kuddus, common.kehf2, common.random];
                return [common.amena];
            }, [mode, t, lang]);

            const current = zikrList[index] || zikrList[0];

            const next = useCallback(() => {
                setCooldown(true); setTimeout(() => setCooldown(false), 500);
                if (index < zikrList.length - 1) {
                    const newIdx = index + 1; setIndex(newIdx); setCount(0); saveProgress(newIdx, 0);
                } else handleCompletion();
            }, [index, zikrList.length, handleCompletion, saveProgress]);

            const tap = useCallback(() => {
                if (isFinishedToday || cooldown) return;
                const isSpecial = current.type?.includes('kehf') || current.type === 'amenarresulu';
                let newCount = count;
                
                const vibrate = (pattern) => { if(navigator.vibrate) navigator.vibrate(pattern); };

                if (isSpecial) {
                    if (count < current.target - 1) {
                        setCooldown(true); setTimeout(() => setCooldown(false), 500);
                        newCount = count + 1;
                        setCount(newCount);
                        if (newCount + 1 >= current.target) vibrate(400); else vibrate(40);
                        saveProgress(index, newCount); 
                    }
                } else if (!current.isReading) {
                    if (count < current.target) {
                        newCount = count + 1;
                        setCount(newCount);
                        if (newCount === current.target) {
                             vibrate(400); 
                        } else {
                             vibrate(40);
                        }
                        saveProgress(index, newCount); 
                    }
                } else if (current.type === 'amenarresulu') {
                      if (count < current.target) {
                        newCount = count + 1;
                        setCount(newCount);
                        if (newCount === current.target) vibrate(400); else vibrate(40);
                        saveProgress(index, newCount); 
                      }
                }

            }, [isFinishedToday, cooldown, current, count, index, saveProgress]);

            return (
                <div className="pb-20 flex flex-col h-full pt-16">
                    <div className="flex bg-slate-100 dark:bg-slate-800 p-1 rounded-lg mb-2 transition-colors duration-300">{['morning', 'ikindi', 'night'].map(m => (
                        <button key={m} onClick={() => setMode(m)} className={`flex-1 py-1.5 text-xs font-medium rounded-md capitalize transition ${mode===m ? 'bg-white dark:bg-slate-700 shadow text-emerald-600 dark:text-emerald-400' : 'text-slate-500 dark:text-slate-400'}`}>{t(m+'Zikr')}</button>
                    ))}</div>
                    {isFinishedToday ? (
                        <div className="flex-1 flex flex-col items-center justify-center p-4 bg-emerald-50 dark:bg-emerald-900/30 rounded-2xl border border-emerald-100 dark:border-emerald-800">
                            <CheckCircle size={40} className="text-emerald-500 dark:text-emerald-400 mb-2"/><h2 className="font-bold text-lg text-emerald-800 dark:text-emerald-100">{t('completed')}</h2>
                            <button onClick={reset} className="mt-4 bg-emerald-600 text-white px-4 py-2 rounded-lg text-xs">{t('reset')}</button>
                        </div>
                    ) : (
                        <div className="flex-1 space-y-2 h-[60vh]">
                             {(current.type?.includes('kehf') || current.type === 'amenarresulu') ? 
                                <FetchableZikrCard current={current} count={count} next={next} tap={tap} cooldown={cooldown} t={t} resetLocal={resetLocal} fontSize={fontSize} lang={lang} /> : 
                              current.type === 'random15' ? <MultiAyahReadingCard current={current} next={next} cooldown={cooldown} t={t} fontSize={fontSize} lang={lang} /> : 
                              (current.isReading ? <ReadingCard current={current} next={next} cooldown={cooldown} t={t} fontSize={fontSize} /> : 
                               <CounterCard current={current} count={count} next={next} tap={tap} cooldown={cooldown} t={t} index={index} totalLength={zikrList.length} resetLocal={resetLocal} fontSize={fontSize} />)}
                        </div>
                    )}
                </div>
            );
        });

        const QuranView = memo(({ t, fontSize, lang }) => {
            const [ayahs, setAyahs] = useState([]);
            const [loading, setLoading] = useState(false);
            const [pageInfo, setPageInfo] = useState(0);

            const load = useCallback(async () => {
                setLoading(true);
                try {
                    let history = JSON.parse(safeStorage.getItem('quran_page_history') || "[]");
                    if (history.length >= 604) history = [];

                    let randomPage;
                    let safety = 0;
                    do {
                        randomPage = Math.floor(Math.random() * 604) + 1; 
                        safety++;
                    } while (history.includes(randomPage) && safety < 1000);
                    
                    safeStorage.setItem('quran_page_history', JSON.stringify([...history, randomPage]));
                    setPageInfo(randomPage);
                    
                    const edition = getEdition(lang);

                    const [p1, p2, p3] = await Promise.all([
                        fetch(`https://api.alquran.cloud/v1/page/${randomPage}/quran-uthmani`).then(r=>r.json()),
                        fetch(`https://api.alquran.cloud/v1/page/${randomPage}/${edition}`).then(r=>r.json()),
                        fetch(`https://api.alquran.cloud/v1/page/${randomPage}/en.transliteration`).then(r=>r.json())
                    ]);

                    if (p1.code === 200 && p2.code === 200 && p3.code === 200) {
                         const combined = p1.data.ayahs.map((item, i) => {
                             const rawTrans = p3.data.ayahs[i] ? p3.data.ayahs[i].text : '';
                             return {
                                 arabic: item.text,
                                 text: p2.data.ayahs[i] ? p2.data.ayahs[i].text : '',
                                 trans: processText(rawTrans, lang),
                                 info: `${getSurahNameTR(item.surah.number)} : ${item.numberInSurah}`
                             };
                         });
                         setAyahs(combined);
                    }
                } catch(e) { console.warn("Load failed", e); }
                setLoading(false);
            }, [lang]);

            return (
                <div className="pb-20 space-y-3 pt-16">
                    <div className="flex justify-between items-center"><h2 className="text-base font-bold text-slate-800 dark:text-slate-100">{t('randomAyahs')} <span className="text-[10px] font-normal text-slate-400">({t('pageInfo')} {pageInfo})</span></h2><button onClick={load} className="p-1.5 bg-emerald-100 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-400 rounded-full"><RefreshCw size={16} className={loading ? "animate-spin" : ""}/></button></div>
                    {ayahs.length === 0 && !loading ? (
                        <div className="text-center py-6 bg-slate-50 dark:bg-slate-800 rounded-xl border border-dashed border-slate-300 dark:border-slate-700"><BookOpen size={24} className="mx-auto text-slate-300 dark:text-slate-600 mb-2"/><button onClick={load} className="bg-emerald-600 text-white px-3 py-1.5 rounded-full text-xs">{t('loadBtn')}</button></div>
                    ) : (
                        <div className="space-y-2">{ayahs.map((a, i) => (
                            <div key={i} className="bg-white dark:bg-slate-850 p-3 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800">
                                <div className="mb-1 border-b border-slate-50 dark:border-slate-800 pb-1 flex justify-between"><span className="text-[9px] font-bold text-emerald-600 dark:text-emerald-400 bg-emerald-50 dark:bg-emerald-900/30 px-1.5 py-0.5 rounded">{a.info}</span></div>
                                <p className="text-right font-serif text-base text-emerald-800 dark:text-emerald-400 mb-1 leading-relaxed" dir="rtl">{a.arabic}</p>
                                <p className="text-slate-800 dark:text-slate-200 font-medium mb-1" style={{ fontSize: `${fontSize * 0.75}rem` }}>{a.trans}</p>
                                <p className="text-slate-500 dark:text-slate-400 italic" style={{ fontSize: `${fontSize * 0.65}rem` }}>{a.text}</p>
                            </div>
                        ))}</div>
                    )} 
                    {loading && <LoadingView />}
                </div>
            );
        });

        const SettingsView = memo(({ t, locationHook, setMethod, setLang, methodId, lang, setAsrMethod, asrMethod, setOffsets, offsets, fontSize, setFontSize }) => (
            <div className="space-y-2 pb-20 pt-16">
                
                {/* Location - Compact */}
                <div className="bg-white dark:bg-slate-850 p-3 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800">
                    <div className="flex justify-between items-center mb-2">
                        <h3 className="font-semibold text-slate-700 dark:text-slate-300 flex items-center text-xs"><MapPin size={14} className="mr-1.5 text-emerald-500" /> {t('location')}</h3>
                        <span className="text-[9px] text-slate-400 max-w-[120px] truncate">{locationHook.locationName}</span>
                    </div>
                    <div className="flex space-x-2"> 
                         <form onSubmit={(e) => { e.preventDefault(); locationHook.searchLocation(e.target.q.value); }} className="flex-1 flex space-x-1">
                            <input name="q" placeholder={t('searchCity')} className="flex-1 border dark:border-slate-700 rounded-lg px-2 py-1.5 text-xs outline-none focus:border-emerald-500 bg-slate-50 dark:bg-slate-900 text-slate-800 dark:text-slate-200 min-w-0"/>
                            <button className="bg-slate-800 dark:bg-slate-700 text-white px-2 rounded-lg"><Icon path={<><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></>} size={14}/></button>
                        </form>
                        <button onClick={locationHook.getUserLocation} className="bg-emerald-50 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-400 px-2 rounded-lg flex items-center justify-center"><Navigation size={14}/></button>
                    </div>
                </div>

                {/* Calculation Method (Dropdown) & Asr Method (Toggle) */}
                <div className="bg-white dark:bg-slate-850 p-3 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800 space-y-3">
                    <div className="flex flex-col space-y-1">
                        <h3 className="font-semibold text-slate-700 dark:text-slate-300 flex items-center text-xs"><Settings size={14} className="mr-1.5 text-emerald-500" /> {t('calcMethod')}</h3>
                        <select 
                             value={methodId} 
                             onChange={(e) => { setMethod(parseInt(e.target.value)); safeStorage.setItem('calcMethod', e.target.value); }}
                            className="w-full bg-slate-50 dark:bg-slate-900 border dark:border-slate-700 rounded-lg px-2 py-1.5 text-xs outline-none focus:border-emerald-500 text-slate-700 dark:text-slate-300"
                        >
                            {CALCULATION_METHODS.map(m => (
                                <option key={m.id} value={m.id}>{m.name}</option>
                            ))}
                        </select>
                    </div>

                    <div className="h-px bg-slate-100 dark:bg-slate-800"></div>

                    <div className="flex justify-between items-center"> 
                         <h3 className="font-semibold text-slate-700 dark:text-slate-300 flex items-center text-xs">{t('asrMethod')}</h3>
                         <div className="flex bg-slate-100 dark:bg-slate-800 p-0.5 rounded-lg">
                            <button onClick={() => { setAsrMethod(0); safeStorage.setItem('asrMethod', 0); }} className={`px-2 py-1 rounded-md text-[10px] transition ${asrMethod === 0 ? 'bg-white dark:bg-slate-600 shadow text-emerald-600 dark:text-emerald-400' : 'text-slate-500 dark:text-slate-400'}`}>{t('standard')}</button>
                            <button onClick={() => { setAsrMethod(1); safeStorage.setItem('asrMethod', 1); }} className={`px-2 py-1 rounded-md text-[10px] transition ${asrMethod === 1 ? 'bg-white dark:bg-slate-600 shadow text-emerald-600 dark:text-emerald-400' : 'text-slate-500 dark:text-slate-400'}`}>{t('hanafi')}</button>
                         </div>
                    </div>
                </div>

                 {/* Font Size & Notifications */}
                 <div className="bg-white dark:bg-slate-850 p-3 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800">
                     <div className="flex justify-between items-center mb-2">
                        <h3 className="font-semibold text-slate-700 dark:text-slate-300 flex items-center text-xs"><Type size={14} className="mr-1.5 text-emerald-500" /> {t('fontSize')}</h3>
                        <span className="text-[10px] font-mono text-slate-400">x{fontSize.toFixed(1)}</span>
                     </div>
                     <input 
                        type="range" min="0.8" max="1.5" step="0.1" value={fontSize} 
                        onChange={(e) => { const v = parseFloat(e.target.value); setFontSize(v); safeStorage.setItem('fontSize', v); }}
                        className="w-full accent-emerald-600 h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer"
                     />
                 </div>

                {/* Notifications & Language - Grid */}
                <div className="grid grid-cols-2 gap-2"> 
                     <div className="bg-white dark:bg-slate-850 p-3 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800 flex flex-col justify-between">
                        <h3 className="font-semibold text-slate-700 dark:text-slate-300 flex items-center text-xs mb-2"><Bell size={14} className="mr-1.5 text-emerald-500" /> {t('notifications')}</h3>
                        <button onClick={async () => { const granted = await requestNotificationPermission(); if(granted) alert(t('notificationGranted')); }} className="w-full bg-emerald-50 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-400 py-1.5 rounded-lg text-[10px] font-medium">{t('enableNotifications')}</button>
                     </div>

                     <div className="bg-white dark:bg-slate-850 p-3 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800 flex flex-col justify-between">
                        <h3 className="font-semibold text-slate-700 dark:text-slate-300 flex items-center text-xs mb-2"><Globe size={14} className="mr-1.5 text-emerald-500" /> {t('language')}</h3>
                        <div className="flex bg-slate-100 dark:bg-slate-800 p-0.5 rounded-lg">
                            {['tr', 'en', 'de'].map(l => (
                                <button key={l} onClick={() => setLang(l)} className={`flex-1 py-1 text-[10px] rounded uppercase ${lang === l ? 'bg-white dark:bg-slate-600 shadow text-emerald-600 dark:text-emerald-400' : 'text-slate-500 dark:text-slate-400'}`}>{l}</button>
                            ))}
                        </div>
                     </div>
                </div>

                {/* Time Offsets - Compact Grid */}
                <div className="bg-white dark:bg-slate-850 p-3 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800">
                    <div className="flex justify-between items-center mb-2">
                        <h3 className="font-semibold text-slate-700 dark:text-slate-300 flex items-center text-xs"><Edit size={14} className="mr-1.5 text-emerald-500" /> {t('timeAdjustments')}</h3>
                        <button onClick={() => safeStorage.setItem('timeOffsets', JSON.stringify(offsets))} className="text-[10px] bg-emerald-100 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-400 px-2 py-0.5 rounded">{t('save')}</button>
                    </div>
                    <div className="grid grid-cols-6 gap-1">
                        {['fajr', 'sunrise', 'dhuhr', 'asr', 'maghrib', 'isha'].map(p => (
                            <div key={p} className="flex flex-col items-center">
                                <label className="text-[8px] text-slate-400 dark:text-slate-500 mb-0.5 capitalize truncate w-full text-center">{t(p).substring(0,3)}</label>
                                <input 
                                     type="number" 
                                     value={offsets[p]} 
                                     onChange={(e) => setOffsets({...offsets, [p]: e.target.value})}
                                    className="w-full border dark:border-slate-700 rounded p-1 text-[10px] text-center bg-slate-50 dark:bg-slate-900 text-slate-800 dark:text-slate-200 outline-none focus:border-emerald-500"
                                />
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        ));

        const Navbar = memo(({ active, setActive, t, className }) => (
            <nav className={`fixed bottom-0 left-0 right-0 mx-auto max-w-md bg-white dark:bg-slate-850 border-t border-slate-100 dark:border-slate-800 px-4 py-2 flex justify-between items-center z-50 shadow-[0_-5px_15px_rgba(0,0,0,0.05)] pb-6 ${className}`}>
                {[{ id: 'times', i: Clock }, { id: 'tasbeeh', i: RefreshCw }, { id: 'quran', i: BookOpen }, { id: 'settings', i: Menu }].map(b => (
                    <button key={b.id} onClick={() => {
                        if (active !== b.id) {
                            window.history.pushState({ tab: b.id }, '', `#${b.id}`);
                            setActive(b.id);
                        }
                    }} className={`flex flex-col items-center space-y-0.5 transition ${active === b.id ? 'text-emerald-600 dark:text-emerald-400 -translate-y-0.5' : 'text-slate-400 dark:text-slate-600'}`}><b.i size={18}/><span className="text-[9px] font-medium max-w-[50px] truncate">{t(b.label || b.id)}</span></button>
                ))}
            </nav>
        ));

        function App() {
            const [lang, setLang] = useState('tr');
            const [activeTab, setActiveTab] = useState('times');
            const [methodId, setMethodId] = useState(13);
            const [isDarkMode, setIsDarkMode] = useState(false);
            const [asrMethod, setAsrMethod] = useState(0); 
            const [offsets, setOffsets] = useState({ fajr: 0, sunrise: 0, dhuhr: 0, asr: 0, maghrib: 0, isha: 0 });
            const [fontSize, setFontSize] = useState(1.0);

            const t = useCallback((k) => TRANSLATIONS[lang][k] || k, [lang]);
            const currentTime = useTime();
            const location = useGeolocation(t);
            const prayerData = usePrayerTimes(location.coords, methodId, asrMethod);

            useEffect(() => {
                const handlePopState = (event) => {
                    if (event.state && event.state.tab) {
                        setActiveTab(event.state.tab);
                    } else {
                        setActiveTab('times');
                    }
                };
                window.addEventListener('popstate', handlePopState);
                return () => window.removeEventListener('popstate', handlePopState);
            }, []);

            useEffect(() => {
                if(prayerData.data) {
                    const times = prayerData.data.timings;
                    const now = new Date();
                    const [ishaH, ishaM] = times.Isha.split(':').map(Number);
                    const [sunH, sunM] = times.Sunrise.split(':').map(Number);
                    const isha = new Date(); isha.setHours(ishaH, ishaM, 0);
                    const sun = new Date(); sun.setHours(sunH, sunM, 0);
                    if (now >= isha || now < sun) setIsDarkMode(true); else setIsDarkMode(false);
                }
            }, [prayerData.data]);

            useEffect(() => { if (isDarkMode) document.documentElement.classList.add('dark'); else document.documentElement.classList.remove('dark'); }, [isDarkMode]);
            const toggleTheme = () => setIsDarkMode(p => !p);
            
            useEffect(() => { 
                 const savedM = safeStorage.getItem('calcMethod');
                 if (savedM) setMethodId(parseInt(savedM));
                 
                 const savedAsr = safeStorage.getItem('asrMethod');
                 if (savedAsr) setAsrMethod(parseInt(savedAsr));

                 const savedOffsets = safeStorage.getItem('timeOffsets');
                 if (savedOffsets) setOffsets(JSON.parse(savedOffsets));

                 const savedFS = safeStorage.getItem('fontSize');
                 if (savedFS) setFontSize(parseFloat(savedFS));
            }, []);

            return (
                <div className="max-w-md mx-auto h-[100dvh] bg-white dark:bg-slate-900 shadow-2xl relative flex flex-col">
                    <Header currentTime={currentTime} appName={t('appName')} toggleTheme={toggleTheme} isDarkMode={isDarkMode} />
                    <main className="flex-1 p-3 overflow-y-auto no-scrollbar relative z-0">
                        {activeTab === 'times' && <PrayerTimesView prayerData={prayerData.data} loading={prayerData.loading} currentTime={currentTime} locationName={location.locationName} t={t} offsets={offsets} />}
                        {activeTab === 'tasbeeh' && <TasbeehView t={t} fontSize={fontSize} lang={lang} />}
                        {activeTab === 'quran' && <QuranView t={t} fontSize={fontSize} lang={lang} />}
                        {activeTab === 'settings' && <SettingsView t={t} locationHook={location} setMethod={setMethodId} setLang={setLang} methodId={methodId} lang={lang} asrMethod={asrMethod} setAsrMethod={setAsrMethod} offsets={offsets} setOffsets={setOffsets} fontSize={fontSize} setFontSize={setFontSize} />}
                    </main>
                    <Navbar active={activeTab} setActive={setActiveTab} t={t} className="shrink-0 z-20" />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
