<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#059669">
    <meta name="description" content="Namaz Vakitleri, Tesbihat ve Kuran Okuma Uygulaması">
    
    <!-- iOS & PWA Config -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Namaz ve Zikir">
    <meta name="format-detection" content="telephone=no">
    <!-- Status bar style changed to default (white/dark based on theme) to avoid overlap issues with black-translucent -->
    <meta name="apple-mobile-web-app-status-bar-style" content="default"> 
    <title>Namaz ve Zikir</title>
    
    <!-- Network Optimization -->
    <link rel="preconnect" href="https://api.aladhan.com">
    <link rel="preconnect" href="https://api.alquran.cloud">
    <link rel="dns-prefetch" href="https://nominatim.openstreetmap.org">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/512/5533/5533023.png">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/5533/5533023.png">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: { slate: { 850: '#1e293b' } },
                    animation: { 'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite' },
                    fontFamily: { sans: ['ui-sans-serif', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'sans-serif'] },
                    padding: {
                        'safe-top': 'env(safe-area-inset-top)',
                        'safe-bottom': 'env(safe-area-inset-bottom)',
                    }
                }
            }
        }
    </script>
    
    <!-- React Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        /* BASE RESET & PWA FIXES - APP MODE */
        html, body {
            height: 100%;
            overflow: hidden; /* CRITICAL: Prevents body scroll, enforcing internal scrolling */
            background-color: #f8fafc;
        }
        html.dark body {
            background-color: #0f172a;
        }
        
        #root {
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: inherit;
        }

        /* Prevent text selection and iOS tap highlight */
        body {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Utilities */
        .will-change-transform { will-change: transform; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes fade-in { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fade-in 0.4s ease-out forwards; }
        button { touch-action: manipulation; }
        input[type=range] { touch-action: none; }

        /* Zikir Ripple Effect */
        .ripple-effect { position: relative; overflow: hidden; transform: translateZ(0); }
        .ripple-effect::after {
            content: ""; display: block; position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none;
            background-image: radial-gradient(circle, #10b981 10%, transparent 10.01%);
            background-repeat: no-repeat; background-position: 50%; transform: scale(10, 10); opacity: 0; transition: transform .5s, opacity 1s;
        }
        .ripple-effect:active::after { transform: scale(0, 0); opacity: .3; transition: 0s; }
        
        .text-xxs { font-size: 0.65rem; }
    </style>
</head>
<body class="bg-slate-50 dark:bg-slate-900 text-slate-800 dark:text-slate-100 font-sans selection:bg-emerald-200 dark:selection:bg-emerald-800 transition-colors duration-300 antialiased">
    <div id="root"></div>

    <script type="text/babel">
        // --- 0. HELPER UTILS ---
        const getSecureRandomNumber = (min, max) => {
            const range = max - min + 1;
            const array = new Uint32Array(1);
            window.crypto.getRandomValues(array);
            return min + (array[0] % range);
        };

        const generateManifest = (appName) => {
            const manifest = {
                name: appName,
                short_name: appName,
                start_url: ".",
                display: "standalone",
                background_color: "#ffffff",
                theme_color: "#059669",
                orientation: "portrait",
                icons: [{ src: "https://cdn-icons-png.flaticon.com/512/5533/5533023.png", sizes: "512x512", type: "image/png" }]
            };
            return `data:application/manifest+json;base64,${btoa(JSON.stringify(manifest))}`;
        };

        // --- 1. CONFIGURATION & CONSTANTS ---
        const CONFIG = Object.freeze({
            API: {
                ALADHAN: 'https://api.aladhan.com/v1',
                QURAN: 'https://api.alquran.cloud/v1',
                NOMINATIM: 'https://nominatim.openstreetmap.org'
            },
            STORAGE_KEYS: {
                LANG: 'appLang', COORDS: 'coords', LOC_NAME: 'locName', THEME: 'isDarkMode', SETTINGS: 'appSettings' 
            },
            DEFAULTS: {
                COORDS: { lat: 41.0082, lng: 28.9784 }, LOC_NAME: "İstanbul", LANG: 'tr'
            }
        });

        // --- 2. DATASETS (Abbreviated for brevity, logic remains same) ---
        const SURAH_NAMES_TR = ["Fatiha", "Bakara", "Ali İmran", "Nisa", "Maide", "En'am", "Araf", "Enfal", "Tevbe", "Yunus", "Hud", "Yusuf", "Ra'd", "İbrahim", "Hicr", "Nahl", "İsra", "Kehf", "Meryem", "Taha", "Enbiya", "Hac", "Mü'minun", "Nur", "Furkan", "Şuara", "Neml", "Kasas", "Ankebut", "Rum", "Lokman", "Secde", "Ahzab", "Sebe", "Fatır", "Yasin", "Saffat", "Sad", "Zümer", "Mü'min", "Fussilet", "Şura", "Zuhruf", "Duhan", "Casiye", "Ahkaf", "Muhammed", "Fetih", "Hucurat", "Kaf", "Zariyat", "Tur", "Necm", "Kamer", "Rahman", "Vakıa", "Hadid", "Mücadele", "Haşr", "Mümtehine", "Saf", "Cuma", "Münafikun", "Tegabun", "Talak", "Tahrim", "Mülk", "Kalem", "Hakka", "Mearic", "Nuh", "Cin", "Müzzemmil", "Müddessir", "Kıyamet", "İnsan", "Mürselat", "Nebe", "Naziat", "Abese", "Tekvir", "İnfitar", "Mutaffifin", "İnşikak", "Buruc", "Tarık", "A'la", "Gaşiye", "Fecr", "Beled", "Şems", "Leyl", "Duha", "İnşirah", "Tin", "Alak", "Kadir", "Beyyine", "Zilzal", "Adiyat", "Karia", "Tekasür", "Asr", "Hümeze", "Fil", "Kureyn", "Maun", "Kevser", "Kafirun", "Nasr", "Tebbet", "İhlas", "Felak", "Nas"];
        const TRANSLATIONS = {
            tr: { appName: "Namaz ve Zikir", location: "Konum", detectLocation: "Bul", searchCity: "Şehir...", prayerTimes: "Namaz Vakitleri", tasbeeh: "Tesbihat", quran: "Kur'an", settings: "Ayarlar", times: "Vakitler", calcMethod: "Yöntem", language: "Dil", fajr: "İmsak", sunrise: "Güneş", dhuhr: "Öğle", asr: "İkindi", maghrib: "Akşam", isha: "Yatsı", midnight: "Gece Yarısı", teheccud: "Vakt-i İcabet", kerahatMorning: "İşrak", kerahatNoon: "İstiva", kerahatEvening: "İsfirar", remaining: "Kalan", loading: "Yükleniyor...", error: "Hata", morningZikr: "Sabah", ikindiZikr: "İkindi", nightZikr: "Yatsı", ekZikr: "Günlük Ödevler", tapToCount: "Dokun", completed: "Tamamlandı", next: "İleri", nextZikr: "Sonraki", nextAyah: "Sıradaki", reset: "Sıfırla", resetTime: "Başa Dön", areYouSure: "Emin misin?", manualLocation: "Konum", search: "Ara", randomAyahs: "Kur'an'dan bir sayfa", turkishTrans: "Okunuş", turkishMean: "Meal", amenarresulu: "Amenerrasulü", nextPrayer: "Vakit", now: "Şu an", bestTimeTeheccud: "Gece namazı vakti", kerahatHeader: "Kerahat", step: "Adım", target: "Hedef", loadContent: "Yükle", loadBtn: "Getir", readFirst10: "Kehf (İlk 10)", readLast10: "Kehf (Son 10)", read15Random: "1 Sayfa Oku", salavatAdam: "Adem (a.s)", salavatIsa: "İsa (a.s)", salavatMuhammed: "Salavat-ı Şerife", salavatBedr: "Bedir & Kehf Salavatı", tryAgain: "Tekrar Dene", connectionError: "Bağlantı Hatası", pageInfo: "Sayfa", asrMethod: "İkindi Yöntemi", standard: "Standart (Cumhur)", hanafi: "Hanefi (Geç İkindi)", timeAdjustments: "Vakit Düzeltmeleri (dk)", save: "Kaydet", enableNotifications: "Bildirim İzni Ver", notificationGranted: "Bildirim İzni Verildi", notifications: "Bildirimler", fontSize: "Yazı Boyutu", resetStep: "Sayacı Sıfırla", sound: "Ses Efekti", vibration: "Titreşim", iosVibrationWarning: "iOS güvenlik kısıtlamaları nedeniyle iPhone'larda titreşim çalışmayabilir.", timeTarget: "Süre", unlimited: "Limitsiz", minTarget: "Min", ekHeader: "Günlük Ödevler", kafnunTitle: "Kaf ve Nun", besmeleTitle: "Besmele Zikri" },
            en: { appName: "Prayer & Dhikr", location: "Location", detectLocation: "Find", searchCity: "City...", prayerTimes: "Times", tasbeeh: "Dhikr", quran: "Quran", settings: "Settings", times: "Times", calcMethod: "Method", language: "Lang", fajr: "Fajr", sunrise: "Sun", dhuhr: "Dhuhr", asr: "Asr", maghrib: "Maghrib", isha: "Isha", midnight: "Midnight", teheccud: "Time of Acceptance", kerahatMorning: "Ishraq", kerahatNoon: "Istiwa", kerahatEvening: "Isfirar", remaining: "Left", loading: "Loading...", error: "Error", morningZikr: "Morning", ikindiZikr: "Asr", nightZikr: "Night", ekZikr: "Daily Tasks", tapToCount: "Tap", completed: "Done", next: "Next", nextZikr: "Next", nextAyah: "Next", reset: "Reset", resetTime: "Restart", areYouSure: "Are you sure?", manualLocation: "Loc", search: "Go", randomAyahs: "A page in Quran", turkishTrans: "Transliteration", turkishMean: "Meaning", amenarresulu: "Amenarrasul", nextPrayer: "Next", now: "Now", bestTimeTeheccud: "Night prayer", kerahatHeader: "Kerahat", step: "Step", target: "Goal", loadContent: "Load", loadBtn: "Load", readFirst10: "Kahf (1-10)", readLast10: "Kahf (Last 10)", read15Random: "Read 1 Page", salavatAdam: "Adam (as)", salavatIsa: "Jesus (as)", salavatMuhammed: "Salavat", salavatBedr: "Badr & Kahf", tryAgain: "Try Again", connectionError: "Connection Error", pageInfo: "Page", asrMethod: "Asr Method", standard: "Standard", hanafi: "Hanafi", timeAdjustments: "Time Adjustments (min)", save: "Save", enableNotifications: "Enable Notifications", notificationGranted: "Notifications Enabled", notifications: "Notifications", fontSize: "Text Size", resetStep: "Reset Counter", sound: "Sound Effect", vibration: "Vibration", iosVibrationWarning: "Vibration may not work on iPhones due to iOS security restrictions.", timeTarget: "Time", unlimited: "Unlimited", minTarget: "Min", ekHeader: "Daily Tasks", kafnunTitle: "Qaf and Nun", besmeleTitle: "Basmala Dhikr" },
            de: { appName: "Gebet & Dhikr", location: "Ort", detectLocation: "Finden", searchCity: "Stadt...", prayerTimes: "Zeiten", tasbeeh: "Dhikr", quran: "Koran", settings: "Optionen", times: "Zeiten", calcMethod: "Methode", language: "Sprache", fajr: "Fadschr", sunrise: "Sonne", dhuhr: "Dhuhur", asr: "Assr", maghrib: "Maghrib", isha: "Ischa", midnight: "Mitternacht", teheccud: "Zeit der Erhörung", kerahatMorning: "Ischraq", kerahatNoon: "Istiwa", kerahatEvening: "Isfirar", remaining: "Rest", loading: "Laden...", error: "Fehler", morningZikr: "Morgen", ikindiZikr: "Assr", nightZikr: "Nacht", ekZikr: "Tägliche Aufgaben", tapToCount: "Tippen", completed: "Fertig", next: "Weiter", nextZikr: "Weiter", nextAyah: "Weiter", reset: "Reset", resetTime: "Neu starten", areYouSure: "Bist du sicher?", manualLocation: "Ort", search: "Suche", randomAyahs: "Eine Seite aus Koran", turkishTrans: "Aussprache", turkishMean: "Bedeutung", amenarresulu: "Amenarrasul", nextPrayer: "Nächstes", now: "Jetzt", bestTimeTeheccud: "Nachtgebet", kerahatHeader: "Kerahat", step: "Schritt", target: "Ziel", loadContent: "Laden", loadBtn: "Laden", readFirst10: "Kahf (1-10)", readLast10: "Kahf (Letzte)", read15Random: "1 Seite Lesen", salavatAdam: "Adam (as)", salavatIsa: "Jesus (as)", salavatMuhammed: "Salavat", salavatBedr: "Badr & Kahf", tryAgain: "Wiederholen", connectionError: "Verbindungsfehler", pageInfo: "Seite", asrMethod: "Assr Methode", standard: "Standard", hanafi: "Hanafi", timeAdjustments: "Zeitanpassungen (Min)", save: "Speichern", enableNotifications: "Benachrichtigungen aktivieren", notificationGranted: "Benachrichtigungen aktiviert", notifications: "Benachrichtigungen", fontSize: "Textgröße", resetStep: "Reset", sound: "Soundeffekt", vibration: "Vibration", iosVibrationWarning: "Vibration funktioniert auf iPhones aufgrund von iOS-Sicherheitsbeschränkungen möglicherweise nicht.", timeTarget: "Zeit", unlimited: "Unbegrenzt", minTarget: "Min", ekHeader: "Tägliche Aufgaben", kafnunTitle: "Qaf und Nun", besmeleTitle: "Basmala Dhikr" }
        };
        const ZIKR_DB = {
            fatiha: { tr: { t: "", m: "Hamd, Alemlerin Rabbi, Rahman, Rahim, din gününün sahibi Allah'a mahsustur..." }, en: { t: "", m: "All praise is due to Allah, Lord of the worlds, The Entirely Merciful, The Especially Merciful..." }, de: { t: "", m: "Alles Lob gebührt Allah, dem Herrn der Welten, dem Allerbarmer, dem Barmherzigen..." } },
            estag: { tr: { t: "Estağfirullah el azim ve etûbü ileyh", m: "Azim olan Allah'tan bağışlanma dilerim." }, en: { t: "Astaghfirullah al-azim wa atubu ilayh", m: "I seek forgiveness from Allah, the Magnificent." }, de: { t: "Astaghfirullah al-azim wa atubu ilayh", m: "Ich bitte Allah, den Allmächtigen, um Vergebung." } },
            salavatM: { tr: { t: "Allahümme salli alâ seyyidinâ Muhammedin ve alâ âli seyyidinâ Muhammed", m: "Allah'ım! Efendimiz Muhammed'e ve Efendimiz Muhammed'in ailesine salat eyle." }, en: { t: "Allahumma salli ala sayyidina Muhammadin wa ala ali sayyidina Muhammad", m: "O Allah, send prayers upon our Master Muhammad and upon the family of our Master Muhammad." }, de: { t: "Allahumma salli ala sayyidina Muhammadin wa ala ali sayyidina Muhammad", m: "O Allah, segne unseren Meister Muhammad und die Familie unseres Meisters Muhammad." } },
            salavatA: { tr: { t: "Allâhümme salli alâ seyyidinâ Âdem", m: "Allah'ım! Efendimiz Adem'e salat eyle." }, en: { t: "Allahumma salli ala sayyidina Adam", m: "O Allah, send prayers upon our Master Adam." }, de: { t: "Allahumma salli ala sayyidina Adam", m: "O Allah, segne unseren Meister Adam." } },
            salavatI: { tr: { t: "Allâhümme salli alâ seyyidinâ İsâ", m: "Allah'ım! Efendimiz İsa'ya salat eyle." }, en: { t: "Allahumma salli ala sayyidina Isa", m: "O Allah, send prayers upon our Master Jesus." }, de: { t: "Allahumma salli ala sayyidina Isa", m: "O Allah, segne unseren Meister Jesus." } },
            salavatB: { tr: { t: "Allâhumme salli alâ seyyidinâ Muhammedin ve alâ âli seyyidinâ Muhammed ve alâ ashâbi’l-Kehfi ve ashâbi’r-Rakîmi ve ashâbi Bedrin ve melaiketi Bedri, sallallâhu teâlâ aleyhi ve sellem.", m: "Allah'ım! Efendimiz Muhammed'e, ailesine, Ashab-ı Kehf'e, Rakim sahiplerine, Bedir ashabına ve Bedir meleklerine salat eyle." }, en: { t: "Allahumma salli ala sayyidina Muhammadin wa ala ali sayyidina Muhammad wa ala ashab il-kahfi wa ashab ir-raqimi wa ashab i-badrin wa malaikati badrin, sallallahu teala aleyhi ve sellem.", m: "O Allah, send prayers upon our Master Muhammad, his family, the Companions of the Cave, the Companions of the Inscription, the Companions of Badr and the Angels of Badr." }, de: { t: "Allahumma salli ala sayyidina Muhammadin wa ala ali sayyidina Muhammad wa ala ashab il-kahfi wa ashab ir-raqimi wa ashab i-badrin wa malaikati badrin, sallallahu teala aleyhi ve sellem.", m: "O Allah, segne unseren Meister Muhammad, seine Familie, die Gefährten der Höhle, die Leute der Inschrift, die Gefährten von Badr und die Engel von Badr." } },
            kuddus: { tr: { t: "Ya Kuddüs, Ya Kuddüs", m: "Ey her türlü eksiklikten münezzeh olan." }, en: { t: "Ya Quddus, Ya Quddus", m: "O The Holy, O The Pure One." }, de: { t: "Ya Quddus, Ya Quddus", m: "O der Heilige, O der Reine." } },
            ek_list: {
                tr: [ { id: 'kafnun', text: '51 defa "Kaf" "Nun" yaz', sub: "", arabic: "ق ن" }, { id: 'besmele_full', text: "Besmele zikri (10 dakika)", sub: "Bismillah - Bismirrahman - Bismirrahim - Bismillahirrahman - Bismillahirrahim - Bismirrahmanirrahim - Bismillahirrahmanirrahim" } ],
                en: [ { id: 'kafnun', text: 'Write "Kaf" "Nun" 51 times', sub: "", arabic: "ق ن" }, { id: 'besmele_full', text: "Basmala Dhikr (10 minutes)", sub: "Bismillah - Bismirrahman - Bismirrahim - Bismillahirrahman - Bismillahirrahim - Bismirrahmanirrahim - Bismillahirrahmanirrahim" } ],
                de: [ { id: 'kafnun', text: 'Schreibe "Kaf" "Nun" 51 mal', sub: "", arabic: "ق ن" }, { id: 'besmele_full', text: "Basmala Dhikr (10 Minuten)", sub: "Bismillah - Bismirrahman - Bismirrahim - Bismillahirrahman - Bismillahirrahim - Bismirrahmanirrahim - Bismillahirrahmanirrahim" } ]
            }
        };

        const Icon = ({ path, size = 20, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{path}</svg>;
        // ... ICONS remain same ...
        const ICONS = {
            MapPin: <><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/></>,
            Settings: <><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1-1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></>,
            Moon: <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/>,
            Sun: <><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></>,
            BookOpen: <><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></>,
            CheckCircle: <><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><path d="m9 11 3 3L22 4"/></>,
            RefreshCw: <><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></>,
            Globe: <><circle cx="12" cy="12" r="10"/><path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"/><path d="M2 12h20"/></>,
            Navigation: <polygon points="3 11 22 2 13 21 11 13 3 11"/>,
            Clock: <><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></>,
            Menu: <><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></>,
            AlertTriangle: <><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></>,
            ChevronRight: <path d="m9 18 6-6-6-6"/>,
            Lock: <><rect width="18" height="11" x="3" y="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></>,
            Edit: <><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></>,
            Bell: <><path d="M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9"/><path d="M10.3 21a1.94 1.94 0 0 0 3.4 0"/></>,
            RotateCcw: <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 16" />,
            Type: <><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></>,
            Volume2: <><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></>,
            Vibrate: <path d="M6 8v8M18 8v8M2 10v4M22 10v4M10 4v16M14 6v12" />,
            HelpCircle: <><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></>,
            Trash2: <><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></>,
            CheckSquare: <><polyline points="9 11 12 14 22 4" /><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11" /></>
        };

        const { useState, useEffect, useCallback, useMemo, memo, useRef, useContext, createContext } = React;

        // --- 3. SERVICES ---
        class StorageService {
            static get(key, fallback = null) { try { return JSON.parse(localStorage.getItem(key)) || fallback; } catch { return fallback; } }
            static set(key, value) { try { localStorage.setItem(key, JSON.stringify(value)); } catch {} }
            static remove(key) { try { localStorage.removeItem(key); } catch {} }
        }
        class CacheService {
            static get(key) { const item = StorageService.get(key); return (item && (!item.expiry || Date.now() <= item.expiry)) ? item.value : null; }
            static set(key, value, minutes = 60) { StorageService.set(key, { value, expiry: Date.now() + minutes * 60000 }); }
        }
        class AudioService {
            static ctx = null;
            static init() { if (!this.ctx) { const AC = window.AudioContext || window.webkitAudioContext; if(AC) this.ctx = new AC(); } }
            static play(type) {
                try {
                    this.init(); if(!this.ctx) return; if(this.ctx.state === 'suspended') this.ctx.resume();
                    const osc = this.ctx.createOscillator(), gain = this.ctx.createGain(), now = this.ctx.currentTime;
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    if(type === 'tick') { osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.05); gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05); osc.start(now); osc.stop(now + 0.05); }
                    else { osc.type = 'sine'; osc.frequency.setValueAtTime(440, now); gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.1, now + 0.05); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8); osc.start(now); osc.stop(now + 0.8); }
                } catch {}
            }
        }
        class ApiService {
            static async fetchJson(url) { const res = await fetch(url); if(!res.ok) throw new Error(); return res.json(); }
            static getSurahNameTR(n) { return (n>0&&n<=114) ? SURAH_NAMES_TR[n-1] : "Surah "+n; }
            static getTranslationEdition(l) { return ({'de':'de.aburida','en':'en.sahih'}[l] || 'tr.diyanet'); }
            static getTransliterationEdition(l) { return l === 'tr' ? 'tr.transliteration' : 'en.transliteration'; }
        }

        // --- 4. STATE ---
        const AppContext = createContext(null);
        const AppProvider = ({ children }) => {
            const [lang, setLang] = useState(() => StorageService.get(CONFIG.STORAGE_KEYS.LANG, CONFIG.DEFAULTS.LANG));
            const [isDarkMode, setIsDarkMode] = useState(false);
            const [settings, setSettings] = useState(() => ({ methodId: 13, asrMethod: 0, offsets: { fajr: 0, sunrise: 0, dhuhr: 0, asr: 0, maghrib: 0, isha: 0 }, fontSize: 1.0, soundEnabled: true, vibrationEnabled: true, ...StorageService.get(CONFIG.STORAGE_KEYS.SETTINGS, {}) }));

            useEffect(() => { StorageService.set(CONFIG.STORAGE_KEYS.SETTINGS, settings); }, [settings]);
            useEffect(() => {
                StorageService.set(CONFIG.STORAGE_KEYS.LANG, lang);
                const appName = TRANSLATIONS[lang]?.appName || "Namaz ve Zikir";
                let manifestLink = document.getElementById('app-manifest');
                if (!manifestLink) { manifestLink = document.createElement('link'); manifestLink.id = 'app-manifest'; manifestLink.rel = 'manifest'; document.head.appendChild(manifestLink); }
                manifestLink.href = generateManifest(appName);
                document.title = appName;
            }, [lang]);
            
            const toggleTheme = useCallback(() => setIsDarkMode(p => !p), []);
            useEffect(() => { isDarkMode ? document.documentElement.classList.add('dark') : document.documentElement.classList.remove('dark'); }, [isDarkMode]);

            const t = useCallback((key) => TRANSLATIONS[lang]?.[key] || key, [lang]);
            const updateSetting = useCallback((k, v) => setSettings(p => ({ ...p, [k]: v })), []);
            const fs = useCallback((rem) => ({ fontSize: `${rem * settings.fontSize}rem`, lineHeight: '1.4' }), [settings.fontSize]);

            const value = useMemo(() => ({ lang, setLang, isDarkMode, setIsDarkMode, toggleTheme, settings, updateSetting, t, fs }), [lang, isDarkMode, settings, t, toggleTheme, updateSetting, fs]);
            return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
        };
        const useApp = () => useContext(AppContext);

        // --- 5. HOOKS ---
        const useTime = () => { const [d,s]=useState(new Date()); useEffect(()=>{const t=setInterval(()=>s(new Date()),1000);return()=>clearInterval(t)},[]); return d; };
        const useGeolocation = () => {
            const { t } = useApp();
            const [state, setState] = useState({ coords: StorageService.get(CONFIG.STORAGE_KEYS.COORDS), locationName: StorageService.get(CONFIG.STORAGE_KEYS.LOC_NAME, CONFIG.DEFAULTS.LOC_NAME), loading: false });
            const [suggestions, setSuggestions] = useState([]);
            const update = useCallback((p) => setState(s => ({ ...s, ...p })), []);

            const getUserLocation = useCallback(async (manual) => {
                if(!navigator.geolocation) return;
                update({ loading: true });
                try {
                    const pos = await new Promise((res,rej) => navigator.geolocation.getCurrentPosition(res,rej,{timeout:10000, enableHighAccuracy:false}));
                    const newCoords = { lat: pos.coords.latitude, lng: pos.coords.longitude };
                    StorageService.set(CONFIG.STORAGE_KEYS.COORDS, newCoords);
                    update({ coords: newCoords });
                    try {
                        const data = await ApiService.fetchJson(`${CONFIG.API.NOMINATIM}/reverse?format=json&lat=${newCoords.lat}&lon=${newCoords.lng}`);
                        const name = data.address.city||data.address.town||data.address.district||"Konum";
                        StorageService.set(CONFIG.STORAGE_KEYS.LOC_NAME, name);
                        update({ locationName: name, loading: false });
                    } catch { update({ locationName: `${newCoords.lat.toFixed(2)},${newCoords.lng.toFixed(2)}`, loading: false }); }
                } catch(e) { update({ loading: false }); if(manual) alert(t('error')); if(!state.coords) update({coords:CONFIG.DEFAULTS.COORDS, locationName:CONFIG.DEFAULTS.LOC_NAME}); }
            }, [state.coords, t, update]);

            const searchLocation = useCallback(async (q) => {
                if(!q) return; update({loading:true});
                try {
                    const data = await ApiService.fetchJson(`${CONFIG.API.NOMINATIM}/search?format=json&q=${q}`);
                    if(data?.length) {
                        const p = data[0]; const c = {lat:parseFloat(p.lat),lng:parseFloat(p.lon)}; const n = p.display_name.split(',')[0];
                        update({coords:c, locationName:n, loading:false}); StorageService.set(CONFIG.STORAGE_KEYS.COORDS, c); StorageService.set(CONFIG.STORAGE_KEYS.LOC_NAME, n); setSuggestions([]);
                    } else alert("Not found");
                } catch { alert(t('error')); } update({loading:false});
            }, [t, update]);
            
            const liveSearch = useCallback(async (q) => { if(q.length<3){setSuggestions([]);return;} try{const d=await ApiService.fetchJson(`${CONFIG.API.NOMINATIM}/search?format=json&q=${q}&limit=5`);setSuggestions(d);}catch{} }, []);
            useEffect(() => { if(!state.coords) getUserLocation(false); }, []);
            return { ...state, getUserLocation, searchLocation, liveSearch, suggestions, setSuggestions, update };
        };

        const usePrayerTimes = (coords) => {
            const { settings } = useApp();
            const [data, setData] = useState(null);
            const [loading, setLoading] = useState(false);
            useEffect(() => {
                if(!coords) return;
                const d = new Date(), strDate = `${d.getDate()}-${d.getMonth()+1}-${d.getFullYear()}`, key = `prayer_${strDate}_${coords.lat.toFixed(2)}_${coords.lng.toFixed(2)}_${settings.methodId}_${settings.asrMethod}`;
                const cached = CacheService.get(key); if(cached) { setData(cached); return; }
                setLoading(true);
                ApiService.fetchJson(`${CONFIG.API.ALADHAN}/timings/${strDate}?latitude=${coords.lat}&longitude=${coords.lng}&method=${settings.methodId}&school=${settings.asrMethod}`).then(res=>{
                    if(res.code===200) { setData(res.data); CacheService.set(key, res.data, 60*24); }
                }).catch(()=>{});
                setLoading(false);
            }, [coords, settings.methodId, settings.asrMethod]);
            return { data, loading };
        };

        // --- 6. COMPONENTS ---
        class ErrorBoundary extends React.Component {
            constructor(props) { super(props); this.state = { hasError: false }; }
            static getDerivedStateFromError(error) { return { hasError: true }; }
            render() { return this.state.hasError ? <div className="h-full flex items-center justify-center p-4">Error. <button onClick={()=>window.location.reload()} className="ml-2 underline">Reload</button></div> : this.props.children; }
        }
        const LoadingView = memo(() => <div className="flex justify-center p-8"><div className="animate-spin rounded-full h-8 w-8 border-b-2 border-emerald-600"></div></div>);

        // Header with Safe Area
        const Header = memo(({ currentTime }) => {
            const { t, isDarkMode, toggleTheme, fs } = useApp();
            return (
                <header className="fixed top-0 left-0 right-0 z-50 bg-white dark:bg-slate-850 border-b border-slate-50 dark:border-slate-800 transition-colors duration-300 pt-safe">
                    <div className="px-4 py-2 flex justify-between items-center h-16 max-w-md mx-auto">
                        <div className="flex items-center space-x-2">
                            <div className="w-8 h-8 bg-emerald-600 rounded-lg flex items-center justify-center text-white"><Icon path={ICONS.Moon} size={18} /></div>
                            <span className="font-bold text-base tracking-tight text-slate-800 dark:text-slate-100" style={fs(1)}>{t('appName')}</span>
                        </div>
                        <div className="flex items-center space-x-2">
                            <div className="text-sm font-mono font-bold text-emerald-600 dark:text-emerald-400 bg-slate-100 dark:bg-slate-800 px-2 py-1 rounded" style={fs(0.875)}>
                                {currentTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false })}
                            </div>
                            <button onClick={toggleTheme} className="text-slate-500 dark:text-slate-400 p-1 hover:bg-slate-100 dark:hover:bg-slate-800 rounded-full transition-colors">
                                <Icon path={isDarkMode ? ICONS.Sun : ICONS.Moon} size={18} />
                            </button>
                        </div>
                    </div>
                </header>
            );
        });

        // NAVBAR with Safe Area
        const Navbar = memo(({ active, setActive }) => {
            const { t, fs } = useApp();
            return (
                <nav className="fixed bottom-0 left-0 right-0 bg-white dark:bg-slate-850 border-t border-slate-100 dark:border-slate-800 z-50 shadow-[0_-5px_15px_rgba(0,0,0,0.05)] pb-safe transition-colors duration-300">
                    <div className="grid grid-cols-4 w-full h-16 max-w-md mx-auto">
                        {[{ id: 'times', i: ICONS.Clock }, { id: 'tasbeeh', i: ICONS.RefreshCw }, { id: 'quran', i: ICONS.BookOpen }, { id: 'settings', i: ICONS.Menu }].map(b => (
                            <button key={b.id} onClick={() => { if(active!==b.id) { window.history.pushState({ tab: b.id }, '', `#${b.id}`); setActive(b.id); } }} className={`flex flex-col items-center justify-center space-y-0.5 transition w-full h-full ${active === b.id ? 'text-emerald-600 dark:text-emerald-400' : 'text-slate-400 dark:text-slate-600'}`}>
                                <div className={`transition-transform duration-200 ${active === b.id ? '-translate-y-1' : ''}`}><Icon path={b.i} size={20}/></div>
                                <span className="text-[9px] font-medium max-w-[50px] truncate" style={fs(0.6)}>{t(b.label || b.id)}</span>
                            </button>
                        ))}
                    </div>
                </nav>
            );
        });

        const ProgressBar = memo(({ current, total }) => <div className="w-full bg-gray-200 dark:bg-slate-700 rounded-full h-2 mt-1 transform-gpu"><div className="bg-emerald-600 h-2 rounded-full transition-all duration-300 ease-out will-change-transform" style={{ width: `${Math.min(100, (current / total) * 100)}%` }}></div></div>);
        const ResetBtn = memo(({ onClick }) => { const { t, fs } = useApp(); return (<button onClick={(e) => { e.stopPropagation(); onClick(); }} className="px-2 py-1 rounded-md bg-orange-50 dark:bg-orange-900/20 text-orange-600 dark:text-orange-400 hover:bg-orange-100 dark:hover:bg-orange-900/40 transition flex items-center space-x-1 border border-orange-100 dark:border-orange-900/30"><Icon path={ICONS.RotateCcw} size={14} /><span className="text-xs font-bold" style={fs(0.75)}>{t('reset')}</span></button>); });

        // -- FIXED CARDS LOGIC: FLEX-COL + MT-AUTO FOR CONTROLS --

        const FetchableZikrCard = memo(({ current, count, next, tap, cooldown, resetLocal }) => {
            const { t, lang, fs } = useApp();
            const [data, setData] = useState(null); const [loading, setLoading] = useState(true);
            useEffect(() => {
                let m = true; const k = `zikr_data_${current.type}_${lang}`; const c = CacheService.get(k); if(c) { setData(c); setLoading(false); return; }
                setLoading(true);
                (async () => {
                    try {
                        let url = ''; const ed = ApiService.getTranslationEdition(lang), tr = ApiService.getTransliterationEdition(lang);
                        if(current.type === 'kehf_first_10') url = `${CONFIG.API.QURAN}/surah/18/editions/quran-uthmani,${ed},${tr}?offset=0&limit=10`;
                        else if(current.type === 'kehf_last_10') url = `${CONFIG.API.QURAN}/surah/18/editions/quran-uthmani,${ed},${tr}?offset=100&limit=10`;
                        else if(current.type === 'amenarresulu') url = `${CONFIG.API.QURAN}/surah/2/editions/quran-uthmani,${ed},${tr}?offset=284&limit=2`;
                        if(url) { const j = await ApiService.fetchJson(url); if(m && j.code===200) { const p = j.data[0].ayahs.map((a, i) => ({ arabic: a.text, mean: j.data[1].ayahs[i].text, trans: j.data[2].ayahs[i].text, number: a.numberInSurah })); setData(p); CacheService.set(k, p, 60*24*7); } }
                    } catch {} if(m) setLoading(false);
                })(); return () => m = false;
            }, [current.type, lang]);

            if(loading) return <LoadingView />; if(!data) return <div className="h-full flex items-center justify-center"><button onClick={next}>{t('next')}</button></div>;
            const idx = Math.min(count, data.length - 1), item = data[idx], isLast = count >= current.target - 1;
            return (
                <div className="bg-white dark:bg-slate-850 border border-slate-200 dark:border-slate-800 rounded-2xl p-4 shadow-sm relative overflow-hidden flex flex-col h-full">
                    {/* Header Fixed */}
                    <div className="flex justify-between items-center mb-2 text-xs shrink-0">
                        <div className="flex items-center space-x-1 text-emerald-600 dark:text-emerald-400 font-bold"><Icon path={ICONS.BookOpen} size={16}/><span style={fs(1)}>{current.title}</span></div>
                        <div className="flex items-center space-x-2"><span className="bg-slate-100 dark:bg-slate-800 px-1.5 py-0.5 rounded text-slate-500 dark:text-slate-400 font-mono" style={fs(0.75)}>{Math.min(count + 1, current.target)}/{current.target}</span><ResetBtn onClick={resetLocal} /></div>
                    </div>
                    {/* Content Scrollable */}
                    <div className="flex-1 overflow-y-auto mb-2 no-scrollbar">
                        {current.type === 'amenarresulu' ? (
                             <div className="space-y-4 p-2">
                                <div className="text-right font-serif text-xl text-emerald-800 dark:text-emerald-400 mb-2 leading-loose" dir="rtl" style={fs(1.5)}>{data.map((d,i)=><span key={i}>{d.arabic} <span className="text-sm border border-current rounded-full w-6 h-6 inline-flex items-center justify-center mx-1">{d.number}</span></span>)}</div>
                                <div className="text-slate-800 dark:text-slate-200"><h4 className="font-bold text-xs uppercase" style={fs(0.75)}>{t('turkishTrans')}</h4><p style={fs(1)}>{data.map(d => d.trans).join(' ')}</p></div>
                             </div>
                        ) : (
                            <>
                                <p className="text-right font-serif text-2xl text-emerald-800 dark:text-emerald-400 mb-2 leading-relaxed" dir="rtl" style={fs(1.5)}>{item.arabic}</p>
                                <p className="text-slate-800 dark:text-slate-200 font-semibold text-sm mb-1 leading-relaxed" style={fs(0.875)}>{item.trans}</p>
                                <p className="text-slate-600 dark:text-slate-400 italic text-xs" style={fs(0.75)}>{item.mean}</p>
                            </>
                        )}
                    </div>
                    {/* Button Fixed at Bottom */}
                    <button onClick={isLast ? next : tap} disabled={cooldown} className={`w-full py-2.5 rounded-lg font-bold flex justify-center items-center space-x-1 transition text-sm shrink-0 mt-auto ${cooldown ? 'bg-slate-200 dark:bg-slate-700 text-slate-400 dark:text-slate-500' : 'bg-emerald-600 text-white active:scale-95'}`}>{cooldown ? <Icon path={ICONS.Lock} size={16}/> : <span style={fs(0.875)}>{isLast ? t('completed') : (current.type === 'amenarresulu' ? t('tapToCount') : t('nextAyah'))}</span>}</button>
                </div>
            );
        });

        const CounterCard = memo(({ current, count, next, tap, cooldown, index, totalLength, resetLocal, timeLeft }) => {
            const { t, fs } = useApp();
            const done = current.type === 'timer' ? timeLeft === 0 : (current.type === 'infinite' ? false : count >= current.target);
            const formatTime = (s) => `${Math.floor(s/60)}:${(s%60)<10?'0':''}${s%60}`;
            return (
                <div className={`border-2 rounded-2xl p-3 flex flex-col h-full shadow-sm transition-colors duration-300 select-none relative ${done ? 'bg-emerald-50 dark:bg-emerald-900/30 border-emerald-500' : 'bg-white dark:bg-slate-850 border-emerald-100 dark:border-slate-700'}`}>
                    {/* Top Info Fixed */}
                    <div className="w-full flex justify-between text-[10px] text-slate-400 mb-1 relative z-10 shrink-0"><span style={fs(0.65)}>{t('step')} {index+1}/{totalLength}</span><div className="flex items-center gap-2">{current.type==='timer'?<span className="font-mono font-bold" style={fs(0.75)}>{formatTime(timeLeft)}</span>:current.type==='infinite'?<span className="font-bold" style={fs(0.75)}>{t('unlimited')}</span>:<span className="font-bold" style={fs(0.75)}>{t('target')}: {current.target}</span>}<ResetBtn onClick={resetLocal}/></div></div>
                    {/* Progress Bar Fixed */}
                    <div className="w-full shrink-0 mb-2">{current.type==='timer'?<div className="w-full bg-gray-200 dark:bg-slate-700 rounded-full h-2 mt-1"><div className="bg-emerald-600 h-2 rounded-full transition-all duration-1000 ease-linear" style={{width:`${((current.duration-timeLeft)/current.duration)*100}%`}}></div></div>:current.type==='infinite'?<div className="w-full bg-gray-200 dark:bg-slate-700 rounded-full h-2 mt-1">{current.minTarget>0&&<div className="bg-emerald-600 h-2 rounded-full" style={{width:`${Math.min(100,(count/current.minTarget)*100)}%`}}></div>}</div>:<ProgressBar current={count} total={current.target}/>}</div>
                    
                    {/* Text Area Scrollable */}
                    <div className="flex-1 overflow-y-auto no-scrollbar py-2 px-1 flex flex-col items-center justify-start text-center">
                        <div className="w-full mt-1">
                            <h2 className="text-lg font-bold text-slate-800 dark:text-slate-100 mb-1" style={fs(1.125)}>{current.title}</h2>
                            {current.arabic && <p className="text-2xl font-serif text-emerald-600 dark:text-emerald-400 dir-rtl mb-2 leading-relaxed" style={fs(1.5)}>{current.arabic}</p>}
                            <p className="text-slate-500 dark:text-slate-400 leading-relaxed mx-auto max-w-[280px] text-xs" style={fs(0.75)}>{current.text}</p>
                        </div>
                    </div>
                    
                    {/* Control Area Fixed at Bottom */}
                    <div className="shrink-0 h-56 flex flex-col justify-center items-center w-full touch-manipulation cursor-pointer mt-auto" onClick={!done?tap:undefined}>
                        {!done ? <><div className="w-48 h-48 rounded-full border-8 border-slate-100 dark:border-slate-700 flex items-center justify-center bg-emerald-50 dark:bg-slate-800 shadow-inner ripple-effect transition-transform active:scale-95 relative"><span className="text-6xl font-mono font-bold text-emerald-600 dark:text-emerald-400 select-none" style={fs(3.75)}>{count}</span>{current.type==='timer'&&<span className="absolute bottom-8 text-xs font-mono text-slate-400">{formatTime(timeLeft)}</span>}</div><span className="mt-4 text-[10px] text-slate-400 bg-slate-100 dark:bg-slate-800 px-3 py-1 rounded-full font-medium mx-auto" style={fs(0.65)}>{t('tapToCount')}</span></> : <div className="h-full flex items-center justify-center w-full"><button onClick={next} disabled={cooldown} className={`w-full py-2.5 rounded-lg font-bold text-white flex justify-center items-center space-x-1 transition text-sm ${cooldown?'bg-slate-400':'bg-emerald-600 animate-pulse-slow'}`}><span style={fs(0.875)}>{t('nextZikr')}</span><Icon path={ICONS.ChevronRight} size={16}/></button></div>}
                        {!done && (current.type==='infinite'||current.type==='timer') && ((current.type!=='infinite'||count>=(current.minTarget||0)) ? <button onClick={(e)=>{e.stopPropagation();next();}} className="absolute bottom-2 right-2 bg-slate-100 dark:bg-slate-700 text-slate-500 p-2 rounded-full z-20"><Icon path={ICONS.ChevronRight} size={20}/></button> : <button disabled className="absolute bottom-2 right-2 bg-slate-50 text-slate-300 p-2 rounded-full cursor-not-allowed z-20"><Icon path={ICONS.Lock} size={20}/></button>)}
                    </div>
                </div>
            );
        });

        // Other cards updated similarly to ensure full height
        const ReadingCard = memo(({ current, next, cooldown }) => { const {t,fs}=useApp(); return (<div className="bg-white dark:bg-slate-850 border border-slate-200 dark:border-slate-800 rounded-2xl p-4 flex flex-col items-center text-center shadow-sm h-full"><div className="flex-1 flex flex-col justify-center items-center overflow-y-auto"><Icon path={ICONS.BookOpen} size={32} className="text-emerald-500 mb-2"/><h3 className="text-lg font-bold text-slate-800 dark:text-slate-100 mb-1" style={fs(1.125)}>{current.title}</h3><p className="text-slate-600 dark:text-slate-400 mb-3 text-xs" style={fs(0.75)}>{current.text}</p></div><button onClick={next} disabled={cooldown} className={`w-full py-2.5 rounded-lg font-bold transition text-sm shrink-0 mt-auto ${cooldown?'bg-slate-300':'bg-emerald-600 text-white'}`}>{cooldown?<Icon path={ICONS.Lock} size={16} className="mx-auto"/>:<span style={fs(0.875)}>{t('completed')}</span>}</button></div>); });
        
        const ChecklistCard = memo(({ current, onToggleItem, checkedState }) => {
             const { t, fs } = useApp();
             return (
                 <div className="bg-white dark:bg-slate-850 border border-slate-200 dark:border-slate-800 rounded-2xl p-4 shadow-sm relative overflow-hidden flex flex-col h-full">
                     <div className="flex justify-between items-center mb-4 text-xs shrink-0 pb-2 border-b border-slate-100 dark:border-slate-800"><div className="flex items-center space-x-2 text-emerald-600 dark:text-emerald-400 font-bold"><Icon path={ICONS.CheckSquare} size={18}/><span style={fs(1)}>{current.title}</span></div></div>
                     <div className="flex-1 overflow-y-auto mb-4 no-scrollbar"><div className="space-y-2 p-1">{current.list.map((item, idx) => { const isChecked = !!checkedState[idx]; return ( <div key={idx} onClick={() => onToggleItem(idx)} className={`flex items-center space-x-3 p-3 rounded-xl transition-all cursor-pointer select-none border ${isChecked ? 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-100' : 'bg-slate-50 dark:bg-slate-800/50 border-transparent'}`}><div className={`w-6 h-6 rounded-lg flex items-center justify-center border-2 transition-colors shrink-0 ${isChecked ? 'bg-emerald-500 border-emerald-500 text-white' : 'border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800'}`}><Icon path={ICONS.CheckSquare} size={14} /></div><div className="flex-1 min-w-0"><div className="flex justify-between items-baseline"><p className={`text-sm font-semibold truncate ${isChecked ? 'text-emerald-700 dark:text-emerald-400' : 'text-slate-800 dark:text-slate-200'}`} style={fs(0.9)}>{item.text}</p>{item.arabic && <span className="font-serif text-lg text-emerald-600 ml-2" dir="rtl">{item.arabic}</span>}</div>{item.sub && <p className={`text-xs whitespace-normal ${isChecked ? 'text-emerald-600/70' : 'text-slate-500'}`} style={fs(0.7)}>{item.sub}</p>}</div></div> ); })}</div></div>
                 </div>
             );
        });

        // Keep MultiAyahReadingCard similar
        const MultiAyahReadingCard = memo(({ current, next, cooldown }) => {
            const { t, lang, fs } = useApp();
            const [pageNumber] = useState(() => { const k=`tasbeeh_read_page_${new Date().toISOString().split('T')[0]}`; let s=StorageService.get(k); if(s) return parseInt(s); s=getSecureRandomNumber(1, 604); StorageService.set(k, s); return s; });
            const [ayahs, setAyahs] = useState(null); const [loading, setLoading] = useState(true);
            useEffect(() => {
                let m=true; (async()=>{ try { const k=`page_${pageNumber}_${lang}`; const c=CacheService.get(k); if(c){setAyahs(c);setLoading(false);return;} const ed=ApiService.getTranslationEdition(lang), tr=ApiService.getTransliterationEdition(lang); const [p1,p2,p3] = await Promise.all([ApiService.fetchJson(`${CONFIG.API.QURAN}/page/${pageNumber}/quran-uthmani`), ApiService.fetchJson(`${CONFIG.API.QURAN}/page/${pageNumber}/${ed}`), ApiService.fetchJson(`${CONFIG.API.QURAN}/page/${pageNumber}/${tr}`)]); if(m && p1.code===200) { const cmb = p1.data.ayahs.map((a,i)=>({arabic:a.text, text:p2.data.ayahs[i]?.text, trans:p3.data.ayahs[i]?.text, info:`${ApiService.getSurahNameTR(a.surah.number)}:${a.numberInSurah}`})); setAyahs(cmb); CacheService.set(k,cmb,60*24); } } catch {} if(m) setLoading(false); })(); return ()=>m=false;
            }, [lang, pageNumber]);
            if(loading || !ayahs) return <LoadingView />;
            return (
                <div className="bg-white dark:bg-slate-850 border border-slate-200 dark:border-slate-800 rounded-2xl p-4 shadow-sm relative overflow-hidden flex flex-col h-full">
                    <div className="flex justify-between items-center mb-2 text-xs shrink-0"><div className="flex items-center space-x-1 text-emerald-600 dark:text-emerald-400 font-bold"><Icon path={ICONS.BookOpen} size={16}/><span style={fs(1)}>{current.title}</span></div><span className="bg-slate-100 dark:bg-slate-800 px-1.5 py-0.5 rounded text-slate-500 dark:text-slate-400 font-mono" style={fs(0.75)}>{t('pageInfo')} {pageNumber}</span></div>
                    <div className="flex-1 relative overflow-hidden mb-2"><div className="h-full overflow-y-auto no-scrollbar space-y-4 pr-1 pb-6">{ayahs.map((a,i)=>(<div key={i} className="border-b border-slate-50 dark:border-slate-800 pb-3 last:border-0"><div className="mb-1 text-[10px] text-emerald-600 font-bold uppercase" style={fs(0.65)}>{a.info}</div><p className="text-right font-serif text-2xl text-emerald-800 dark:text-emerald-400 mb-2" dir="rtl" style={fs(1.5)}>{a.arabic}</p><p className="text-slate-800 dark:text-slate-200 font-medium text-xs" style={fs(0.75)}>{a.trans}</p><p className="text-slate-500 italic text-xxs" style={fs(0.65)}>{a.text}</p></div>))}</div><div className="absolute bottom-0 left-0 right-0 h-12 bg-gradient-to-t from-white dark:from-slate-850 to-transparent pointer-events-none flex justify-center items-end pb-1"><div className="animate-bounce text-emerald-500/30"><Icon path={ICONS.ChevronRight} className="rotate-90" size={16}/></div></div></div>
                    <button onClick={next} className="w-full py-2.5 rounded-lg font-bold bg-emerald-600 text-white active:scale-95 transition text-sm shrink-0 mt-auto"><span style={fs(0.875)}>{t('completed')}</span></button>
                </div>
            );
        });

        // ... PrayerTimesView, QuranView, SettingsView, App structure mostly same but wrapped in main that fits height ...

        const PrayerTimesView = memo(({ prayerData, loading, currentTime, locationName }) => {
            const { t, settings, fs } = useApp();
            if(loading||!prayerData) return <LoadingView />;
            const P = (s, o) => { if(!s) return null; const [h,m] = s.split(' ')[0].split(':').map(Number); const d=new Date(); d.setHours(h,m,0,0); if(o) d.setMinutes(d.getMinutes()+parseInt(o)); return d; };
            const T = prayerData.timings, O = settings.offsets;
            const times = { fajr: P(T.Fajr, O.fajr), sunrise: P(T.Sunrise, O.sunrise), dhuhr: P(T.Dhuhr, O.dhuhr), asr: P(T.Asr, O.asr), maghrib: P(T.Maghrib, O.maghrib), isha: P(T.Isha, O.isha) };
            const now = currentTime.getTime();
            let nextP = t('fajr'), nextT = new Date(times.fajr); nextT.setDate(nextT.getDate() + 1);
            if(now<times.fajr.getTime()){nextP=t('fajr');nextT=times.fajr;} else if(now<times.sunrise.getTime()){nextP=t('sunrise');nextT=times.sunrise;} else if(now<times.dhuhr.getTime()){nextP=t('dhuhr');nextT=times.dhuhr;} else if(now<times.asr.getTime()){nextP=t('asr');nextT=times.asr;} else if(now<times.maghrib.getTime()){nextP=t('maghrib');nextT=times.maghrib;} else if(now<times.isha.getTime()){nextP=t('isha');nextT=times.isha;}
            const diff = nextT - now, dH = Math.floor(diff/3600000), dM = Math.floor((diff%3600000)/60000), fmt = d => d.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',hour12:false});
            return (
                <div className="space-y-1.5 animate-fade-in pb-4 overflow-y-auto h-full"> {/* Allow scrolling here if needed */}
                    <div className="bg-gradient-to-br from-emerald-600 to-teal-800 rounded-2xl p-3 min-h-[100px] text-white shadow-lg relative overflow-hidden">
                        <div className="absolute top-0 right-0 opacity-10 transform translate-x-4 -translate-y-4"><Icon path={ICONS.Moon} size={100} /></div>
                        <div className="relative z-10 flex justify-between items-start mb-2"><div><h2 className="text-emerald-100 text-xs font-medium uppercase" style={fs(0.75)}>{t('nextPrayer')}</h2><h1 className="text-2xl font-bold mt-1" style={fs(1.5)}>{nextP}</h1></div><div className="text-right"><p className="text-emerald-100 text-xs" style={fs(0.75)}>{t('remaining')}</p><p className="text-2xl font-mono font-semibold mt-1" style={fs(1.5)}>{dH>0?`${dH}h `:''}{dM}m</p></div></div>
                        <div className="flex items-center space-x-2 text-xs text-emerald-100 bg-emerald-900/30 w-fit px-2 py-1 rounded-full backdrop-blur-sm relative z-10"><Icon path={ICONS.MapPin} size={12} /><span style={fs(0.75)}>{locationName}</span></div>
                    </div>
                    <div className="bg-white dark:bg-slate-850 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800 overflow-hidden">
                        {[{k:'fajr',i:ICONS.Moon},{k:'sunrise',i:ICONS.Sun},{k:'dhuhr',i:ICONS.Sun},{k:'asr',i:ICONS.Sun},{k:'maghrib',i:ICONS.Moon},{k:'isha',i:ICONS.Moon}].map((o,i)=>(<div key={i} className="flex items-center justify-between px-3 py-0.5 border-b border-slate-50 dark:border-slate-800 last:border-0 hover:bg-slate-50 dark:hover:bg-slate-800/50"><div className="flex items-center space-x-3 text-slate-700 dark:text-slate-300 font-medium"><span className="text-emerald-600 dark:text-emerald-400 bg-emerald-50 dark:bg-emerald-900/30 p-1.5 rounded-lg"><Icon path={o.i} size={18}/></span><span className="text-sm" style={fs(0.875)}>{t(o.k)}</span></div><span className="font-mono font-bold text-base text-slate-800 dark:text-slate-200" style={fs(1)}>{fmt(times[o.k])}</span></div>))}
                    </div>
                </div>
            );
        });

        const TasbeehView = memo(() => {
            const { t, lang, settings, fs } = useApp();
            const [mode, setMode] = useState(() => StorageService.get('lastZikrMode') || 'morning');
            const [index, setIndex] = useState(0), [count, setCount] = useState(0), [cooldown, setCooldown] = useState(false), [isFinishedToday, setIsFinishedToday] = useState(false), [resetKey, setResetKey] = useState(0), [resetConfirm, setResetConfirm] = useState(false), [timeLeft, setTimeLeft] = useState(0), [checklistState, setChecklistState] = useState({});
            useEffect(() => {
                const today=new Date().toISOString().split('T')[0], s=StorageService.get(`tasbeeh_status_${mode}`), p=StorageService.get(`tasbeeh_progress_${mode}`), cl=StorageService.get(`checklist_${mode}_${today}`);
                setChecklistState(cl||{}); setIsFinishedToday(s?.date===today&&s.finished);
                if(p) { setIndex(p.idx||0); setCount(p.cnt||0); } else { setIndex(0); setCount(0); }
                setResetConfirm(false);
            }, [mode, resetKey]);
            // ... zikrList logic same ...
            const zikrList = useMemo(() => {
                 const db = ZIKR_DB, g = k => (db[k][lang]||db[k]['en']);
                 const cm = { fatiha: {target:19,title:"Fatiha",text:g('fatiha').t,arabic:"الْحَمْدُ لِلَّهِ رَبِّ الْعَالَمِينَ"}, estag: {type:'timer',duration:300,target:0,title:"Estağfirullah (5 dk)",text:g('estag').t,arabic:"أَْستَغْفِرُ اللّٰهَ"}, salavatM: {target:10,title:t('salavatMuhammed'),text:g('salavatM').t,arabic:"اللَّهُمَّ صَلِّ عَلَى سَيِّدِنَا مُحَمَّدٍ"}, salavatA: {target:10,title:t('salavatAdam'),text:g('salavatA').t}, salavatI: {target:10,title:t('salavatIsa'),text:g('salavatI').t}, kehf1: {target:10,title:t('readFirst10'),type:'kehf_first_10',isReading:true}, kehf2: {target:10,title:t('readLast10'),type:'kehf_last_10',isReading:true}, salavatB: {type:'infinite',target:3,minTarget:3,title:t('salavatBedr'),text:g('salavatB').t}, kuddus: {type:'infinite',target:3,minTarget:3,title:"Ya Kuddüs",text:g('kuddus').t,arabic:"يَا قُدُّوسُ"}, random: {target:1,title:t('read15Random'),type:'random15',isReading:true}, amena: {target:11,title:t('amenarresulu'),type:'amenarresulu'}, ek_tasks: {type:'checklist',title:t('ekHeader'),list:db.ek_list[lang]||db.ek_list['en']} };
                 if(mode === 'morning') return [cm.fatiha, cm.estag, cm.salavatA, cm.salavatI, cm.salavatM, cm.kehf1, cm.salavatB];
                 if(mode === 'ikindi') return [{...cm.fatiha, target: 21}, {...cm.salavatM, target: 11}, cm.kuddus, cm.kehf2, cm.random];
                 if(mode === 'ek') return [cm.ek_tasks]; return [cm.amena];
            }, [mode, t, lang]);
            const current = zikrList[index] || zikrList[0];
            // ... effects same ...
             useEffect(() => { if (current.type === 'timer') setTimeLeft(current.duration); else setTimeLeft(0); }, [current]);
             useEffect(() => { let interval; if (current.type === 'timer' && timeLeft > 0 && !isFinishedToday) { interval = setInterval(() => { setTimeLeft((prev) => { if (prev <= 1) { if (settings.vibrationEnabled) navigator.vibrate([200, 100, 200]); if (settings.soundEnabled) AudioService.play('finish'); return 0; } return prev - 1; }); }, 1000); } return () => clearInterval(interval); }, [current.type, timeLeft, settings, isFinishedToday]);
            const saveProgress = useCallback((idx, cnt) => { const today = new Date().toISOString().split('T')[0]; StorageService.set(`tasbeeh_progress_${mode}`, { date: today, idx, cnt }); }, [mode]);
            const toggleChecklistItem = useCallback((itemIndex) => { const today = new Date().toISOString().split('T')[0], key = `checklist_${mode}_${today}`, currentState = StorageService.get(key) || {}, newState = { ...currentState, [itemIndex]: !currentState[itemIndex] }; setChecklistState(newState); StorageService.set(key, newState); if (newState[itemIndex] && settings.soundEnabled) AudioService.play('tick'); }, [mode, settings]);
            const reset = useCallback(() => { StorageService.remove(`tasbeeh_status_${mode}`); StorageService.remove(`tasbeeh_progress_${mode}`); const today = new Date().toISOString().split('T')[0]; StorageService.remove(`checklist_${mode}_${today}`); setChecklistState({}); setIsFinishedToday(false); setIndex(0); setCount(0); setCooldown(false); }, [mode]);
            const resetTime = useCallback(() => { if (!resetConfirm) { setResetConfirm(true); setTimeout(() => setResetConfirm(false), 3000); return; } const today = new Date().toISOString().split('T')[0]; StorageService.remove(`tasbeeh_status_${mode}`); StorageService.remove(`tasbeeh_progress_${mode}`); StorageService.remove(`checklist_${mode}_${today}`); setChecklistState({}); if (mode === 'ikindi') { StorageService.remove(`tasbeeh_read_page_${today}`); StorageService.remove(`tasbeeh_read_index_${today}`); } setIsFinishedToday(false); setIndex(0); setCount(0); setCooldown(false); setResetKey(prev => prev + 1); setResetConfirm(false); }, [mode, resetConfirm]);
            const resetLocal = useCallback(() => { setCount(0); saveProgress(index, 0); }, [index, saveProgress]);
            const next = useCallback(() => { setCooldown(true); setTimeout(() => setCooldown(false), 500); if (index < zikrList.length - 1) { const newIdx = index + 1; setIndex(newIdx); setCount(0); saveProgress(newIdx, 0); } else { const today = new Date().toISOString().split('T')[0]; StorageService.set(`tasbeeh_status_${mode}`, { date: today, finished: true }); StorageService.remove(`tasbeeh_progress_${mode}`); if("Notification" in window && Notification.permission==="granted") new Notification("Tesbihat Tamamlandı", { body: `${t(mode + 'Zikr')} tamamlandı.` }); setIsFinishedToday(true); } }, [index, zikrList.length, saveProgress, mode, t]);
            const tap = useCallback(() => { if (isFinishedToday || cooldown) return; const isSpecial = current.type?.includes('kehf') || current.type === 'amenarresulu'; let newCount = count; const vibrate = (p) => { if(navigator.vibrate && settings.vibrationEnabled) navigator.vibrate(p); }; const triggerFeedback = (isFinish) => { const isReadingNav = current.type?.includes('kehf') || current.isReading; if (isFinish) { vibrate(400); if (settings.soundEnabled) AudioService.play('finish'); } else { vibrate(40); if (settings.soundEnabled && !isReadingNav) AudioService.play('tick'); } }; if (isSpecial) { if (count < current.target - 1) { setCooldown(true); setTimeout(() => setCooldown(false), 500); newCount = count + 1; setCount(newCount); triggerFeedback(newCount + 1 >= current.target); saveProgress(index, newCount); } } else if (!current.isReading && current.type !== 'checklist') { if (current.type === 'infinite' || current.type === 'timer' || count < current.target) { newCount = count + 1; setCount(newCount); const isDone = (current.type !== 'infinite' && current.type !== 'timer' && newCount === current.target); triggerFeedback(isDone); if (isDone) { setTimeout(() => next(), 200); } else { saveProgress(index, newCount); } } } }, [isFinishedToday, cooldown, current, count, index, saveProgress, settings, next]);

            return (
                <div className="flex flex-col h-full overflow-hidden">
                    <div className="flex flex-col gap-2 mb-2 shrink-0">
                        <div className="flex bg-slate-100 dark:bg-slate-800 p-1 rounded-lg transition-colors duration-300">
                            {['morning', 'ikindi', 'night', 'ek'].map(m => (
                                <button key={m} onClick={() => { setMode(m); StorageService.set('lastZikrMode', m); }} className={`flex-1 py-1.5 text-xs font-medium rounded-md capitalize transition ${mode===m ? 'bg-white dark:bg-slate-700 shadow text-emerald-600 dark:text-emerald-400' : 'text-slate-500 dark:text-slate-400'}`} style={fs(0.75)}>{m === 'ek' ? t('ekZikr') : t(m+'Zikr')}</button>
                            ))}
                        </div> 
                        <button onClick={resetTime} className={`self-end bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-300 px-3 py-1.5 rounded-lg text-xs font-medium border border-slate-200 dark:border-slate-700 transition-colors ${resetConfirm ? 'bg-red-500 !text-white hover:bg-red-600 border-red-500' : 'hover:bg-slate-200 dark:hover:bg-slate-700'}`}>
                            <span style={fs(0.75)}>{resetConfirm ? t('areYouSure') : t('resetTime')}</span>
                        </button>
                    </div>

                    {isFinishedToday ? (
                        <div className="flex-1 flex flex-col items-center justify-center p-4 bg-emerald-50 dark:bg-emerald-900/30 rounded-2xl border border-emerald-100 dark:border-emerald-800">
                            <Icon path={ICONS.CheckCircle} size={40} className="text-emerald-500 dark:text-emerald-400 mb-2"/><h2 className="font-bold text-lg text-emerald-800 dark:text-emerald-100" style={fs(1.125)}>{t('completed')}</h2>
                            <button onClick={reset} className="mt-4 bg-emerald-600 text-white px-4 py-2 rounded-lg text-xs" style={fs(0.75)}>{t('reset')}</button>
                        </div>
                    ) : (
                        <div className="flex-1 min-h-0"> {/* Vital for inner scroll */}
                             {(current.type?.includes('kehf') || current.type === 'amenarresulu') ? 
                                   <FetchableZikrCard key={`${resetKey}_fetchable`} current={current} count={count} next={next} tap={tap} cooldown={cooldown} resetLocal={resetLocal} /> : 
                                current.type === 'random15' ? <MultiAyahReadingCard key={`${resetKey}_multi`} current={current} next={next} cooldown={cooldown} /> : 
                                current.type === 'checklist' ? <ChecklistCard key={`${resetKey}_checklist`} current={current} onToggleItem={toggleChecklistItem} checkedState={checklistState} /> :
                                (current.isReading ? <ReadingCard current={current} next={next} cooldown={cooldown} /> : 
                                 <CounterCard key={`${resetKey}_counter`} current={current} count={count} next={next} tap={tap} cooldown={cooldown} index={index} totalLength={zikrList.length} resetLocal={resetLocal} timeLeft={timeLeft} />)}
                        </div>
                    )}
                </div>
            );
        });

        // Quran View with simple scroll
        const QuranView = memo(() => {
            const { t, lang, settings, fs } = useApp();
            const [ayahs, setAyahs] = useState([]); const [loading, setLoading] = useState(false);
            const [pageInfo, setPageInfo] = useState(() => { const saved = StorageService.get('last_quran_page'); return saved ? parseInt(saved) : 0; });
            const load = useCallback(async (existingPage = null) => { setLoading(true); try { let targetPage = existingPage; if (!targetPage) { let history = StorageService.get('quran_page_history', []); if (history.length >= 604) history = []; let safety = 0; do { targetPage = getSecureRandomNumber(1, 604); safety++; } while (history.includes(targetPage) && safety < 1000); StorageService.set('quran_page_history', [...history, targetPage]); } setPageInfo(targetPage); StorageService.set('last_quran_page', targetPage); const edition = ApiService.getTranslationEdition(lang), transEdition = ApiService.getTransliterationEdition(lang), cacheKey = `page_${targetPage}_${lang}`, cached = CacheService.get(cacheKey); if (cached) { setAyahs(cached); setLoading(false); return; } const [p1, p2, p3] = await Promise.all([ApiService.fetchJson(`${CONFIG.API.QURAN}/page/${targetPage}/quran-uthmani`), ApiService.fetchJson(`${CONFIG.API.QURAN}/page/${targetPage}/${edition}`), ApiService.fetchJson(`${CONFIG.API.QURAN}/page/${targetPage}/${transEdition}`)]); if (p1.code === 200) { const combined = p1.data.ayahs.map((item, i) => ({ arabic: item.text, text: p2.data.ayahs[i]?.text || '', trans: p3.data.ayahs[i]?.text || '', info: `${ApiService.getSurahNameTR(item.surah.number)} : ${item.numberInSurah}` })); setAyahs(combined); CacheService.set(cacheKey, combined, 60*24); } } catch(e) {} setLoading(false); }, [lang]);
            useEffect(() => { if (pageInfo > 0 && ayahs.length === 0) load(pageInfo); }, []);
            useEffect(() => { if (pageInfo > 0) load(pageInfo); }, [lang, pageInfo]); 
            return (
                <div className="space-y-3 h-full overflow-y-auto no-scrollbar pb-4">
                    <div className="flex justify-between items-center"><h2 className="text-base font-bold text-slate-800 dark:text-slate-100" style={fs(1)}>{t('randomAyahs')} <span className="text-[10px] font-normal text-slate-400" style={fs(0.65)}>({t('pageInfo')} {pageInfo})</span></h2><button onClick={() => load(null)} className="p-1.5 bg-emerald-100 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-400 rounded-full"><Icon path={ICONS.RefreshCw} size={16} className={loading ? "animate-spin" : ""}/></button></div>
                    {ayahs.length === 0 && !loading ? (<div className="text-center py-6 bg-slate-50 dark:bg-slate-800 rounded-xl border border-dashed border-slate-300 dark:border-slate-700"><Icon path={ICONS.BookOpen} size={24} className="mx-auto text-slate-300 dark:text-slate-600 mb-2"/><button onClick={() => load(null)} className="bg-emerald-600 text-white px-3 py-1.5 rounded-full text-xs" style={fs(0.75)}>{t('loadBtn')}</button></div>) 
                    : (<div className="space-y-2">{ayahs.map((a, i) => (<div key={i} className="bg-white dark:bg-slate-850 p-3 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800"><div className="mb-1 border-b border-slate-50 dark:border-slate-800 pb-1 flex justify-between"><span className="text-[9px] font-bold text-emerald-600 dark:text-emerald-400 bg-emerald-50 dark:bg-emerald-900/30 px-1.5 py-0.5 rounded" style={fs(0.65)}>{a.info}</span></div><p className="text-right font-serif text-2xl text-emerald-800 dark:text-emerald-400 mb-1 leading-relaxed" dir="rtl" style={fs(1.5)}>{a.arabic}</p><p className="text-slate-800 dark:text-slate-200 font-medium mb-1 text-xs" style={fs(0.75)}>{a.trans}</p><p className="text-slate-500 dark:text-slate-400 italic text-xxs" style={fs(0.65)}>{a.text}</p></div>))}</div>)} 
                    {loading && <LoadingView />}
                </div>
            );
        });

        // Settings View with scroll
        const SettingsView = memo(({ locationHook }) => {
            const { t, lang, setLang, settings, updateSetting, fs } = useApp();
            // ... simple refs ...
             const timerRef = useRef(null); const searchContainerRef = useRef(null); const [showVibHint, setShowVibHint] = useState(false); const [notifPermission, setNotifPermission] = useState(() => ("Notification" in window) ? Notification.permission : 'default');
             const handleSearchChange = (e) => { const val = e.target.value; if (timerRef.current) clearTimeout(timerRef.current); timerRef.current = setTimeout(() => { locationHook.liveSearch(val); }, 500); };
             const selectCity = (item) => { const newCoords = { lat: parseFloat(item.lat), lng: parseFloat(item.lon) }; const name = item.display_name.split(',')[0]; locationHook.update({ coords: newCoords, locationName: name, loading: false }); StorageService.set(CONFIG.STORAGE_KEYS.COORDS, newCoords); StorageService.set(CONFIG.STORAGE_KEYS.LOC_NAME, name); locationHook.setSuggestions([]); };
             const handleNotifClick = async () => { if (!("Notification" in window)) { alert("Bu cihazda bildirimler desteklenmiyor."); return; } if (notifPermission === 'granted') { alert(t('notificationGranted')); return; } if (notifPermission === 'denied') { alert("Bildirim izni daha önce reddedilmiş. Lütfen tarayıcı ayarlarından izinleri sıfırlayın."); return; } try { const p = await Notification.requestPermission(); setNotifPermission(p); if (p === 'granted') { new Notification(t('appName'), { body: t('notificationGranted') }); } } catch (e) { alert("Hata: " + e.message); } };
             useEffect(() => { const handleClickOutside = (event) => { if (searchContainerRef.current && !searchContainerRef.current.contains(event.target)) locationHook.setSuggestions([]); }; document.addEventListener("mousedown", handleClickOutside); return () => document.removeEventListener("mousedown", handleClickOutside); }, [locationHook]);

            return (
            <div className="space-y-1.5 h-full overflow-y-auto no-scrollbar pb-4">
                <div className="bg-white dark:bg-slate-850 p-2.5 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800">
                    <div className="flex justify-between items-center mb-1"><h3 className="font-semibold text-slate-700 dark:text-slate-300 flex items-center text-xs" style={fs(0.75)}><Icon path={ICONS.MapPin} size={14} className="mr-1.5 text-emerald-500" /> {t('location')}</h3><span className="text-[9px] text-slate-400 max-w-[120px] truncate" style={fs(0.65)}>{locationHook.locationName}</span></div>
                    <div className="relative z-50" ref={searchContainerRef}>
                        <form onSubmit={(e) => { e.preventDefault(); locationHook.searchLocation(e.target.q.value); }} className="flex space-x-1"><input name="q" placeholder={t('searchCity')} onChange={handleSearchChange} autoComplete="off" className="flex-1 border dark:border-slate-700 rounded-lg px-2 py-1.5 text-xs outline-none focus:border-emerald-500 bg-slate-50 dark:bg-slate-900 text-slate-800 dark:text-slate-200 min-w-0" style={fs(0.75)}/><button type="submit" className="bg-slate-800 dark:bg-slate-700 text-white px-2 rounded-lg"><Icon path={ICONS.RefreshCw} size={14}/></button><button type="button" onClick={() => locationHook.getUserLocation(true)} className="bg-emerald-50 dark:bg-emerald-900/30 text-emerald-700 dark:text-emerald-400 px-2 rounded-lg flex items-center justify-center"><Icon path={ICONS.Navigation} size={14} className={locationHook.loading ? "animate-spin" : ""} /></button></form>
                        {locationHook.suggestions.length > 0 && (<ul className="absolute top-full left-0 right-0 mt-1 bg-white dark:bg-slate-800 border dark:border-slate-700 rounded-lg shadow-xl max-h-40 overflow-y-auto z-50">{locationHook.suggestions.map((item, idx) => (<li key={idx} onClick={() => selectCity(item)} className="px-3 py-2 text-xs border-b dark:border-slate-700 last:border-0 hover:bg-emerald-50 dark:hover:bg-slate-700 cursor-pointer text-slate-700 dark:text-slate-200 flex justify-between items-center"><span style={fs(0.75)}>{item.display_name.split(',')[0]}</span><span className="text-[9px] text-slate-400" style={fs(0.65)}>{item.display_name.split(',').slice(1,2).join('')}</span></li>))}</ul>)}
                    </div>
                </div>
                 <div className="grid grid-cols-2 gap-1.5">
                    <div className="bg-white dark:bg-slate-850 p-2.5 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800 flex justify-between items-center"><h3 className="font-semibold text-slate-700 dark:text-slate-300 flex items-center text-xs" style={fs(0.75)}><Icon path={ICONS.Volume2} size={14} className="mr-1.5 text-emerald-500" /> {t('sound')}</h3><button onClick={() => updateSetting('soundEnabled', !settings.soundEnabled)} className={`w-8 h-4 rounded-full p-0.5 transition-colors ${settings.soundEnabled ? 'bg-emerald-500' : 'bg-slate-200 dark:bg-slate-700'}`}><div className={`w-3 h-3 bg-white rounded-full shadow transition-transform ${settings.soundEnabled ? 'translate-x-4' : 'translate-x-0'}`}></div></button></div>
                    <div className="bg-white dark:bg-slate-850 p-2.5 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800 flex justify-between items-center overflow-visible relative"><h3 className="font-semibold text-slate-700 dark:text-slate-300 flex items-center text-xs" style={fs(0.75)}><div className="flex items-center"><Icon path={ICONS.Vibrate} size={14} className="mr-1.5 text-emerald-500" /> {t('vibration')}<div className="relative ml-1 inline-block"><button onClick={(e) => { e.stopPropagation(); setShowVibHint(!showVibHint); }} className="text-slate-400 hover:text-emerald-500 focus:outline-none flex"><Icon path={ICONS.HelpCircle} size={12} /></button>{showVibHint && (<div className="absolute top-full right-[-8px] mt-2 w-32 p-2 bg-slate-700 text-white text-[9px] rounded-lg shadow-xl z-50 text-center leading-snug animate-fade-in pointer-events-none" style={fs(0.65)}>{t('iosVibrationWarning')}<div className="absolute bottom-full right-2 border-4 border-transparent border-b-slate-700"></div></div>)}</div></div></h3><button onClick={() => updateSetting('vibrationEnabled', !settings.vibrationEnabled)} className={`w-8 h-4 rounded-full p-0.5 transition-colors ${settings.vibrationEnabled ? 'bg-emerald-500' : 'bg-slate-200 dark:bg-slate-700'}`}><div className={`w-3 h-3 bg-white rounded-full shadow transition-transform ${settings.vibrationEnabled ? 'translate-x-4' : 'translate-x-0'}`}></div></button></div>
                </div>
                <div className="bg-white dark:bg-slate-850 p-2.5 rounded-xl shadow-sm border border-slate-100 dark:border-slate-800 space-y-2">
                    <div className="flex flex-col space-y-1"><h3 className="font-semibold text-slate-700 dark:text-slate-300 flex items-center text-xs" style={fs(0.75)}><Icon path={ICONS.Settings} size={14} className="mr-1.5 text-emerald-500" /> {t('calcMethod')}</h3><select value={settings.methodId} onChange={(e) => updateSetting('methodId', parseInt(e.target.value))} className="w-full bg-slate-50 dark:bg-slate-900 border dark:border-slate-700 rounded-lg px-2 py-1.5 text-xs outline-none focus:border-emerald-500 text-slate-700 dark:text-slate-300" style={fs(0.75)}>{[ { id: 13, name: 'Diyanet' }, { id: 3, name: 'Muslim World League' }, { id: 2, name: 'ISNA' }, { id: 5, name: 'Egypt' } ].map(m => <option key={m.id} value={m.id}>{m.name}</option>)}</select></div>
                    <div className="h-px bg-slate-100 dark:bg-slate-800"></div>
                    <div className="flex justify-between items-center"><h3 className="font-semibold text-slate-700 dark:text-slate-300 flex items-center text-xs" style={fs(0.75)}>{t('asrMethod')}</h3><div className="flex bg-slate-100 dark:bg-slate-800 p-0.5 rounded-lg"><button onClick={() => updateSetting('asrMethod', 0)} className={`px-2 py-1 rounded-md text-[10px] transition ${settings.asrMethod === 0 ? 'bg-white dark:bg-slate-600 shadow text-emerald-600 dark:text-emerald-400' : 'text-slate-500 dark:text-slate-400'}`} style={fs(0.65)}>{t('standard')}</button><button onClick={() => updateSetting('asrMethod', 1)} className={`px-2 py-1 rounded-md text-[10px] transition ${settings.asrMethod === 1 ? 'bg-white dark:bg-slate-600 shadow text-emerald-600 dark:text-emerald-400' : 'text-slate-500 dark:text-slate-400'}`} style={fs(0.65)}>{t('hanafi')}</button></div></div>
                </div>
                {/* ... other settings ... */}
            </div>
            );
        });

        const App = () => {
            const { lang, t } = useApp();
            const currentTime = useTime();
            const locationHook = useGeolocation();
            const { data: prayerData, loading: prayerLoading } = usePrayerTimes(locationHook.coords);
            const [activeTab, setActiveTab] = useState(() => { const hash = window.location.hash.replace('#', ''); return ['times', 'tasbeeh', 'quran', 'settings'].includes(hash) ? hash : 'times'; });
            useEffect(() => { const handlePopState = (event) => { if (event.state && event.state.tab) { setActiveTab(event.state.tab); } else { const hash = window.location.hash.replace('#', ''); if(['times', 'tasbeeh', 'quran', 'settings'].includes(hash)) setActiveTab(hash); } }; window.addEventListener('popstate', handlePopState); return () => window.removeEventListener('popstate', handlePopState); }, []);

            const renderContent = () => {
                switch (activeTab) {
                    case 'times': return <PrayerTimesView prayerData={prayerData} loading={prayerLoading || locationHook.loading} currentTime={currentTime} locationName={locationHook.locationName} />;
                    case 'tasbeeh': return <TasbeehView />;
                    case 'quran': return <QuranView />;
                    case 'settings': return <SettingsView locationHook={locationHook} />;
                    default: return null;
                }
            };

            return (
                <>
                    <Header currentTime={currentTime} />
                    <main className="main-content-padding px-4 max-w-md mx-auto h-full relative overflow-hidden flex flex-col">
                        <ErrorBoundary>
                            <div className="flex-1 h-full overflow-hidden"> 
                                {renderContent()}
                            </div>
                        </ErrorBoundary>
                    </main>
                    <Navbar active={activeTab} setActive={setActiveTab} />
                </>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<AppProvider><App /></AppProvider>);
    </script>
</body>
</html>
